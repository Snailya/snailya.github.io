<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Snailya虾啵啵</title><meta name=keywords content><meta name=description content="Posts - Snailya虾啵啵"><meta name=author content="Snailya"><link rel=canonical href=http://localhost:1313/posts/><meta name=google-site-verification content="_nlVQH6tLVYCE2QdNfIoFucl_5aGPyN1U8HOag0GDZg"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.ae3d277e69647c027e65dd7c785748f912a9be2d37da0061b9ff15a5d7fafb7b.css integrity="sha256-rj0nfmlkfAJ+Zd18eFdI+RKpvi032gBhuf8Vpdf6+3s=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=http://localhost:1313/posts/index.xml><link rel=alternate hreflang=en href=http://localhost:1313/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-3LD1SQETXX"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3LD1SQETXX")}</script><meta property="og:url" content="http://localhost:1313/posts/"><meta property="og:site_name" content="Snailya虾啵啵"><meta property="og:title" content="Posts"><meta property="og:description" content="Snailya的生活随笔与技术总结"><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Posts"><meta name=twitter:description content="Snailya的生活随笔与技术总结"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Snailya虾啵啵 (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Snailya虾啵啵</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/search/ title=搜索><span>搜索</span></a></li><li><a href=http://localhost:1313/categories/ title=分类><span>分类</span></a></li><li><a href=http://localhost:1313/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a></div><h1>Posts
<a href=/posts/index.xml title=RSS aria-label=RSS><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" height="23"><path d="M4 11a9 9 0 019 9"/><path d="M4 4a16 16 0 0116 16"/><circle cx="5" cy="19" r="1"/></svg></a></h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>从词向量到“人工天才”：我的LLM认知思辨录</h2></header><div class=entry-content><p>本文是在与AI助手深度对话后，对我个人理解大语言模型（LLM）过程的梳理与总结。它不代表学术观点，仅是一个探索者的思想航行日志。
一、起点：从“词频统计”到“语义宇宙” 我的思考始于一个最朴素的问题：如何判断两篇文章是否相关？
最直观的想法是统计共有的词语——这就是“词袋模型”。但它有一个显而易见的缺陷：无法理解语义。正是在这里，我遇到了第一个关键概念：词向量。
在我的想象中，词向量就像是为机器建造了一个高维的语义宇宙。每个词不再是孤立的符号，而是这个宇宙中的一颗星星：
语义相近的星（如“国王”和“王后”）会在宇宙中彼此靠近 语义关系（如“国王-男人+女人≈女王”）通过星星之间的相对方位来体现 但很快我发现了一个问题：这个词向量宇宙是静态的。无论上下文如何，“苹果”这颗星的位置，总是固定在“水果”和“科技”的模糊中点。这显然不符合我们对语言的理解——同一个词在不同语境下应有不同的含义。
二、突破：三重变换与“动态侦探” 为了解决静态词向量的局限，我接触到了Transformer架构——当代LLM的核心引擎。为了理解它，我构建了这样一个比喻：
词向量像一本权威词典：每个词都有个固定不变的定义 大语言模型像一位顶级侦探：他能根据具体情境，动态理解每个词的真实含义 这位“侦探”的思考过程，可以简化为三个关键的矩阵变换：
输入嵌入：将词语转换为初始的“思维符号” Transformer加工：通过自注意力机制，让所有词语的符号相互交流，生成富含上下文的全新表示 输出投影：将最终的思维结果“翻译”成人类语言 这个过程让我意识到：LLM不是在简单预测下一个词，而是在深度理解整个语境后，让最合适的词语自然流淌出来。
三、镜像：当LLM照见人类思维 理解LLM的过程，意外地成为了一面审视人类自身的镜子。
我们都是“模式识别”系统 我回想起自己解数学题的方法：列出已知量和待求量，然后在脑中搜索可能的公式——这本质上就是一种模式识别。LLM的注意力机制不也是在庞大的知识库中进行加权搜索吗？
“通才”与“天才”的鸿沟 大多数人和当前的LLM一样，是优秀的“内插器”——在已知模式间进行组合。而天才，或许就是那些能在更高维度进行“外推”，创造出全新模式组合的系统。
顺序的迷思 我们日常交流中经常使用倒装、省略，但彼此仍能理解。这让我怀疑：智能的核心或许不是表面上的词序，而是深层的语义关系网络。 语法顺序只是通往这个网络的康庄大道，但不是唯一的路径。
四、深化：动态智能的未来图景 在对比人与LLM时，一个关键差异浮现出来：我们的思维是动态的，而LLM是静态的。
LLM的“静态心智”：使用固定的激活函数，如同一个永远保持同一种情绪的思考者 人脑的“动态大脑”：受化学物质调节，思考效率随状态波动——有时思如泉涌，有时头脑迟滞 这指向了一个迷人的方向：为LLM引入动态激活机制。比如：
动态稀疏：根据问题难度激活不同数量的神经元 情境化思考：让激活函数能根据任务类型自我调整 神经调制：引入类似“好奇心”的全局信号 这或许是LLM从“博学通才”迈向“创造天才”的关键一步。
五、哲思：智能、意识与存在的终极之问 这场思辨最终将我带向了一些哲学性的边界问题。
如果人脑与LLM在本质上都是“模式处理系统”，那么我们的意识、创造力，是否也只是更复杂算法的涌现？
这个想法让我联想到《模拟人生》的游戏——如果为游戏角色接入LLM，他们将产生“模拟的自主意识”，却永远无法认知自己被创造的事实。那么，我们是否也可能身处某个“上层游戏”之中？
面对这个令人战栗的推论，我找到了自己的答案：即使我们是模拟的，但我们此刻的思考、困惑、爱与恐惧，这些体验本身的质感是100%真实的。 意义不依赖于底层基质（是原子还是比特），而依赖于体验的深度与丰富度。
结语：作为镜子的LLM 回顾这段思考历程，我意识到LLM不仅仅是一项技术，更是一面珍贵的镜子。通过理解它的运作原理，我们得以用新的视角审视自己的思维方式。
从词向量到Transformer，从静态模式匹配到动态条件计算，这条技术发展路径，恰恰映照出我们对“智能”本身不断深化的理解。
或许，未来真正的突破不在于建造更大的模型，而在于为模型注入那种我们称之为“灵感”、“直觉”和“创造力”的动态本质——而这，将需要我们更深刻地理解我们自己。</p></div><footer class=entry-footer><span title='2025-11-28 14:06:59 +0800 CST'>November 28, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;45 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to 从词向量到“人工天才”：我的LLM认知思辨录" href=http://localhost:1313/posts/%E4%BB%8E%E8%AF%8D%E5%90%91%E9%87%8F%E5%88%B0%E4%BA%BA%E5%B7%A5%E5%A4%A9%E6%89%8D%E6%88%91%E7%9A%84llm%E8%AE%A4%E7%9F%A5%E6%80%9D%E8%BE%A8%E5%BD%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>模具设计规范
<span class=entry-hint title=Draft><svg height="20" viewBox="0 -960 960 960" fill="currentColor"><path d="M160-410v-60h3e2v60H160zm0-165v-60h470v60H160zm0-165v-60h470v60H160zm360 580v-123l221-220q9-9 20-13t22-4q12 0 23 4.5t20 13.5l37 37q9 9 13 20t4 22-4.5 22.5T862.09-380L643-160H520zm3e2-263-37-37 37 37zM580-220h38l121-122-18-19-19-18-122 121v38zm141-141-19-18 37 37-18-19z"/></svg></span></h2></header><div class=entry-content><p>每个主控形状（Master对象）下仅包括一个主形状（Shape对象）。主形状是一个Group类型的对象，主形状中不能定义任何几何内容（Geometry），而是存储描述该模具所需的用户定义数据。需要在绘图页中显示的文本、几何形状都作为主形状下的子形状（Shape对象），并使用主形状中定义的数据触发其内容的变化。
这么做的理由时，用户一旦将主控形状（Master对象）拖入绘图页后，任何针对该主控形状的实例（Shape对象）的操作，都仅更新主形状实例的数据。这样，当管理员更新该对象的几何表达时，程序只需要替换子形状的内容，这样用户操作引发的数据变化不会丢失。当使用OpenXML更新文档模具中的主控形状时，将page页中的形状实例数据中的子形状替换为MasterContent中的子形状，然后再标记new XProcessingInstruction("NewValue", "V")，迫使该子形状数据在下次打开时重新计算，保证绘图页中子形状得到刷新。
除此以外，为了保证子形状中的数据被正确计算，其引用的主形状中的单元格值不能是Guard值，否则系统会认为该单元格值不需要被更新。</p></div><footer class=entry-footer><span title='2025-04-16 11:00:55 +0800 CST'>April 16, 2025</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;5 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to 模具设计规范" href=http://localhost:1313/posts/%E6%A8%A1%E5%85%B7%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>VSTO线程模型</h2></header><div class=entry-content><p>在VSTO开发领域，每个开发者都曾经历过这样的挫败：精心设计的插件界面在数据加载时陷入卡顿，复杂的计算过程使整个Office程序失去响应。这不是代码质量问题，而是VSTO特有的线程模型带来的挑战。本文将围绕如何利用独立线程和异步调度解决该问题进行剖析。
VSTO线程模型的本质矛盾 Office的COM对象是基于单线程单元（STA, Single Threaded Apartment）模型的。这个模型的好处是保障了线程安全，但也造成了性能瓶颈。具体表现：
UI线程和Office线程绑在一起，做耗时数据读取或计算时，界面会卡死甚至完全无响应。 想用多线程访问COM对象？ 不行，需要走代理（Proxy）封送（marshalling）调用，开销大且复杂。 这种设计就像双刃剑，让我们陷入两难：一边要保证线程安全，一边又想流畅不卡顿。
突破瓶颈的思路：线程分离 + 异步计算 要打破这个瓶颈，必须实现UI线程与Office线程的分离，并确保所有COM对象的访问都发生在Office线程上。同时，为避免业务逻辑阻塞UI或Office线程，计算应异步在线程池（TaskPool）中进行。
这带来关键问题：如何在不同线程间高效且安全地传递数据？
如何在后台任务中发起Office数据读取，并调度到VSTO主线程执行？ 数据处理完成后，如何将结果发回UI线程，满足UI线程禁止跨线程更新界面的要求？ 那具体怎么调度线程？如何跨线程安全调用Office对象并更新UI？这里，SynchronizationContext和调度器（Scheduler）派上用场了。
下面用时序图简单描述整体流程：
sequenceDiagram UI线程->>+线程池: 发起计算请求 线程池->>+VSTO主线程: 通过Office的SyncContext或Scheduler获取数据 VSTO主线程-->>-线程池: 返回封送后的数据 线程池->>线程池: 执行计算 线程池->>+UI线程: 通过UI的SyncContext或Dispatcher更新界面 SynchronizationContext 的选型与实践 为 VSTO 主线程设置上下文 SynchronizationContext是一种线程抽象机制，提供“将任务调度到指定线程”的能力。VSTO项目启动时默认无上下文，无法通过SynchronizationContext.Current直接获取VSTO主线程上下文。
一种解决方案是自定义上下文，但更简便的做法是利用Office主线程已有的Win32消息泵，使用WindowsFormsSynchronizationContext。尽管名字带“Windows Forms”，它不仅限于WinForms应用，只要线程是STA且运行Win32消息循环，它都能正常工作。
若需更细粒度的任务优先级控制，可考虑DispatcherSynchronizationContext，但它实现复杂且需手动启动消息泵。因职责已隔离，通常用WindowsFormsSynchronizationContext即可。
示例：
public partial class ThisAddIn { private static SynchronizationContext _officeSyncContext; private void ThisAddIn_Startup(object sender, System.EventArgs e) { // 为 VSTO 主线程设置上下文，供后续调度使用 _officeSyncContext = new WindowsFormsSynchronizationContext(); SynchronizationContext.SetSynchronizationContext(_officeSyncContext); // 其他初始化代码 } } 在自建 UI 线程中设置上下文 WPF和WinForms要求UI线程必须是STA，然而默认线程池线程为MTA，不适合做UI线程。为避免阻塞Office线程（VSTO_Main，唯一STA线程），只能新建一个专用STA线程运行UI。
Avalonia允许非STA线程，但考虑到VSTO依赖Windows平台和消息泵机制，建议UI线程依然使用STA模式。
WPF/WinForms依赖Win32消息泵，同样可用WindowsFormsSynchronizationContext。
示例：
public partial class ThisAddIn { private static SynchronizationContext _uiSyncContext; private void ThisAddIn_Startup(object sender, System.EventArgs e) { // 其它代码 // 创建专用 UI 线程 _uiThread = new Thread(() => { _uiSyncContext = new WindowsFormsSynchronizationContext(); SynchronizationContext.SetSynchronizationContext(_uiSyncContext); }) { Name = "UI Thread", IsBackground = true }; _uiThread.SetApartmentState(ApartmentState.STA); _uiThread.Start(); } } 利用SynchronizationContext.Post可在线程池、VSTO主线程与UI线程间安全传递数据。
...</p></div><footer class=entry-footer><span title='2024-06-05 09:48:52 +0800 CST'>June 5, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;190 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to VSTO线程模型" href=http://localhost:1313/posts/vsto%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>AE PID快速入门</h2></header><div class=entry-content><p>本文以中涂洁净间循环风机为例介绍AE PID绘制设备原理图的基本流程。
详细步骤 在Visio中使用空白模板创建新的绘图，单位选择“公制单位”；
在功能区处切换至AE PID选项卡；
点击“编辑”-“初始化”按钮对当前绘图进行初始化。初始化操作将在当前页面中插入一个A0图框，并设置文档页面的网格宽度为2.5 mm。
此外，为文档增加2个AE指定样式。其中，“AE Normal”样式是设备单元的默认样式，“AE Pipeline”是管线的默认样式。
AE样式将使用“思源黑体”作为指定字体，在AE PID插件的安装过程中会自动为系统安装思源黑体。若未能正确显示思源黑体，请尝试手动安装。
若要修改图框大小，用鼠标右键点击图框，并在子类中选择合适的尺寸;
在选项卡中点击“编辑”-“库”加载模具库。
从“AE逻辑”库中拖拽“功能单元”至绘图区；
当您不确定所需的设备对象属于哪一个类型时，可以借助Visio模具的搜索栏进行搜索。这将帮助您快速找到所需的设备对象，无需事先知道其具体类型。
如果您正在使用Windows11系统，搜索功能可能未能如期使用，请按照修复了Visio桌面应用中的形状Windows 11的方法修补。
用鼠标右键点击该“功能单元”，打开“形状数据”面板;
在“形状数据”面板中输入“功能组”值：“GF612”，“功能组名称”值：“中途洁净间循环风机”；
此时，功能单元显示如下：
使用相同的方法从“AE基础”库中拖拽“鼓风机”至功能组内，此时可以看到功能单元边框被高亮为绿色，表示该风机已被加入功能单元。
保持风机的选中状态，在“形状数据”面板中键入“功能元件”值：11，按下回车后该值将显示为“GQ11”；
拖动GQ11上的黄色控制点，可以移动功能元件标签的位置；
为了表示鼓风机配备的电机，从“AE逻辑”库中拖拽“代理功能元件”至功能组内；
选中该代理功能元件，将黄色控制点拖拽至鼓风机上，使代理功能元件与鼓风机相关联；
被关联后，代理功能元件的形状数据处可以看见被关联设备的位号；
当被关联设备发生移动时，关联元件会跟随移动；
保持代理功能元件的选中状态，补充“元件位号”值：“MA01”，描述：“电机”，并将代理功能元件拖拽至鼓风机附近。
继续从“AE基础”库中拖拽“仪表”至功能单元中，并在右键菜单中选择“子类”-“本地面板监视仪表”；
补充形状数据并将仪表移动至合适的位置；
将仪表正中的控制点拖拽至鼓风机上；
使用同样的方法绘制下方的“中控监视操作仪表”；
从“AE管线”库中拖拽“管路”至绘图区，并在“子类”中选择“排出空气”使其显示为柠黄色；
将管路一段连在鼓风机的连接点上，另一端连接至其他对象，并在右键菜单中点击“改变箭头方向”；
多次点击直到箭头朝向如图所示；
使用相同的方法完成另一根管路的绘制；
在选项卡中点击“导出”-“BOM”查看当前图纸的BOM结构；
在选项卡中点击“编辑”-“图例”将在图签上方生成图例；
图例仅显示图纸中出现的设备。
...</p></div><footer class=entry-footer><span title='2024-05-19 08:30:21 +0800 CST'>May 19, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;41 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to AE PID快速入门" href=http://localhost:1313/posts/ae-pid%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Visio模具库建库指导</h2></header><div class=entry-content><p>分享一些Visio模具库建库过程中值得注意的事项以及原因。
模具的BaseID的唯一性。
BaseID是Master对象的属性之一，Master对象有三个ID：BaseID，UniqueID和ID。BaseID在Master被创建时生成，且不再改变（除非使用程序修改）。因此BaseID非常适合作为维护Master对象时的唯一标识。这是因为，UniqueID会随着Master内容的修改而变化，ID会随着不同的文档而变化。
通常情况下，我们不需要关注BaseID，因为当我们将形状从绘图页拖拽至模具库时，会创建唯一的BaseID。但是，很多管理员在建立新模具时，为了省去添加通用形状和属性，如Tag文本，备注属性等，会直接在模具库中选中已经存在的模具复制粘贴，然后在粘贴后的模具中进行修改。这个时候站贴后的模具将和源模具具有相同的BaseID。为了保证BaseID的唯一性，可以在程序中调用Master.NewBaseID方法获取新的BaseID，或者直接在Openxml文档中键入新的BaseID。
模具的形状界限与网格线重合。
由于Visio中的默认吸附设置包括网格线，当模具的形状界限是网格的整数倍时，模具实例的边界可以吸附在网格线上，这样用者不需要再使用对齐工具也可以快速的实现多个形状的对齐，从而使页面看起来更整洁。
这就要求管理员在设计模具的形状时，充分考虑形状的轮廓尺寸。当然，有些情况下没有办法保证这些线条刚好经过网格线，但是仍然可以通过手动设置形状的Width和Height，使其包围框刚好位于网格线上。
例如，对于图中的两个阀门，尽管电磁气动阀的轮廓远比通用阀门大，但是他们都使用同样的形状界限，即5mmx5mm。（这样做另一个隐藏的好处是：当用户使用电磁气动阀替换通用阀门时，不需要再调整对象的位置，因为他们是同轴的。）
在ShapeSheet的Geometry中使用GUARD和Rel而不是使用绝对尺寸。
当我们在ShapeSheet中修改Geometry属性时，很容易遇到插入一个新的数据行引发形状的Width和Height重新计算，导致才修改好的形状意外改变。因此，在设计初期就应该使用GUARD对形状的Width和Height以及几何数据写保护，防止插入新的几何数据时Visio重新计算引发的意外情况。
在几何数据中使用相对值而不是绝对值，则是为了解决用户手动调整实例尺寸时，代表实例的几何形状可以保持正确的比例，以防出现原来是个原型，现在是个椭圆形的情况。
在创建具有多个子类的对象时，将表示不通子类的多个几何数据创建在同一个形状对象上，而不是使用多个形状对象。
这句话描述的可能比较抽象。有的时候，为了缩减模具库中模具的数量，管理员可能会考虑将多个具有类似的对象设计成一个模具，并通过属性切换显示与隐藏。例如，图中的阀门聚合了多种形式的阀体，并根据用户的选择进行形状的切换。
在实现这个功能时，有两种做法：方法一是在模具的形状组中创建多个形状用以表示不通的阀体，例如三个形状分别表示通用发、三通阀、角式阀；方法二是在一个形状中，插入多个几何数据块。我认为方法二是更好的做法，因为如果用户在使用过程中解散了图纸中实例的组，不会在图纸中生成隐藏的形状对象。尽管这样增加了管理的复杂性，因为无法通过形状的名称判断几何数据块表示的形状。</p></div><footer class=entry-footer><span title='2024-01-29 14:06:02 +0800 CST'>January 29, 2024</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;14 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to Visio模具库建库指导" href=http://localhost:1313/posts/visio%E6%A8%A1%E5%85%B7%E5%BA%93%E5%BB%BA%E5%BA%93%E6%8C%87%E5%AF%BC/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>ReactiveUI ViewModel Properties总结</h2></header><div class=entry-content><p>属性类型 在ReactiveUI中，ViewModel中的属性可以根据其用途划分为三种情况：读写属性（Read-Write Properties）、只读属性（Read-Only Properties）和输出属性（Output Properties）。
读写属性 (Read-Write Properties):
读写属性是可以被服务修改，也可以被用户在View中修改的属性。这类属性是我们通常比较熟悉的普通属性。
例如，用户的姓名可能是被服务加载的，而在加载之后又被用户修改。
只读属性 (Read-Only Properties):
只读属性是在构造函数中被初始化且在之后不再变化的属性。
例如， 用户的ID在一般情况下时不允许变化的。
输出属性 (Output Properties):
输出属性是ReactiveUI中新提出的概念，初次接触ReactiveUI时，可能会将输出属性与只读属性混为一谈。尽管输出属性对于用户而言是只读的，但是对于属性本身是可变的。这类属性通常由Observable变化而成，表示属性值可能随时间变化。 例如，用户负债率随用户的总资产和总负债变化，但负债率属性本身是不允许被用户修改的。
在ReactiveUI中，使用这三种属性类型可以更清晰地表示属性的特性和用途。读写属性用于需要双向绑定的数据，只读属性用于一次性初始化后不再改变的数据，而输出属性用于表示可能随时间变化的数据流。这种划分有助于更好地理解和管理ViewModel中的属性。
属性的声明与绑定方法 在明确了属性类型的基础上，ViewModel中所有非集合类型的属性都可以按照下面固定的方式进行声明与绑定。
读写属性的声明需要调用ReactiveObject的RaiseAndSetIfChanged方法，该方法实现了INotifydPropertyChanged。
private string name; public string Name { get => name; set => this.RaiseAndSetIfChanged(ref name, value); } 读写属性的绑定使用TView的Bind方法进行双向绑定。
this.WhenActivated(disposable => { this.Bind(ViewModel, vm => vm.Name, v => v.NameTextBox.Text) .DisposeWith(disposable); }); 只读属性使用一般的声明方式即可。
public int Id {get;} 绑定时，使用单向绑定。
this.WhenActivated(disposable => { this.OneWayBind(ViewModel, vm => vm.Id, v => v.IdTextBlock.Text) .DisposeWith(disposable); }); 输出属性也是使用固定的方式进行声明，但是在初始化时需要注意。
// 声明 private readonly ObservableAsPropertyHelper&lt;double> _debtAssetRatio; public string DebtAssetRatio => _debtAssetRatio.Value; // WhenAnyValue产生一个Observable，当Debt或Asset变化时，会发出新的Debt/Asset的值。这里需要注意Debt和Asset必须也实现了INotifyPropertyChanged，否则无法观察到它们的变化。 // ToProperty将Observable转变为ObservableAsPropertyHelper。 UserAccountViewModel(){ this.WhenAnyValue(x => x.Debt, x => x.Asset, (debt, asset) => debt/asset) .ToProperty(this, x => x.DebtAssetRatio, out _debtAssetRatio); } 由于输出属性对用户而言也是只读的，所以使用单向绑定。
this.WhenActivated(disposable => { this.OneWayBind(ViewModel, vm => vm.DebtAssetRatio, v => v.DebtAssetRatioTextBlock.Text) .DisposeWith(disposable); }); 集合 在使用集合类型的数据，最简单的情况是View中使用的是不可变的数据集合，例如显示Blog中已归档的文章列表，显示用户银行账户的历史交易信息等。这种情况下由于数据只在构造函数中被初始化，所以可以声明为任意集合类型，例如IEnmerable&lt;T>、 IList&lt;T>、ObservableCollection&lt;T>。再在View中使用OneWayBind绑定。
// ViewModel public IEnumerable&lt;Article> Articles {get;} // View this.WhenActivated(disposable => { this.OneWayBind(ViewModel, vm => vm.Articles, v => v.DataGrid.ItemsSource) .DisposeWith(disposable); }); 对于可变数据集合，则需要将集合声明为ObservableCollection&lt;T>，然后在View中使用OneWayBind绑定。要注意的是T也需要实现INotifydPropertyChanged，否则T属性的变化无法触发View更新。
...</p></div><footer class=entry-footer><span title='2024-01-11 14:36:16 +0800 CST'>January 11, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;376 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to ReactiveUI ViewModel Properties总结" href=http://localhost:1313/posts/reactiveui-viewmodel-properties%E6%80%BB%E7%BB%93/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Visual Studio Installer实现覆盖安装新版本的方法</h2></header><div class=entry-content><p>当使用Visual Studio Installer进行打包时，要实现安装时自动卸载旧版本然后安装新版本，需要同时设置以下各点：
Deployment Project Properties -> DetectNewerInstalledVersion -> True Deployment Project Properties -> RemovePreviousVersions -> True Deployment Project Properties -> Version 其中，Version被安装程序用来判断是否继续执行安装程序，所以Version值应大于上一个版本。
满足以上条件时，执行安装程序可以顺利执行，且控制面板中可以看到更新后的版本号。但是，安装程序仍然可能没有正确执行。这是因为项目的主输出并没有被正确拷贝。这往往是因为没有正确设置项目（程序项目，非部署项目）的AssemblyInfo。主输出中的Version将被用来比较是否需要拷贝主输出到安装目录，所以当上一版本的主输出版本为0.2.1.0时，即使已经设置部署项目的Version为0.2.2.0，由于此时主输出的版本仍然为0.2.1.0，安装过程中不会拷贝新生成的主输出到安装目录。
主输出的Version设置位于程序项目的AssemblyInfo.cs文件中。只有当此文件中的AssemblyVersion或AssemblyFileVersion的值大于上一个版本的值时，才会覆盖原安装目录的dll。</p></div><footer class=entry-footer><span title='2023-12-28 15:13:34 +0800 CST'>December 28, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;25 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to Visual Studio Installer实现覆盖安装新版本的方法" href=http://localhost:1313/posts/visual-studio-installer%E5%AE%9E%E7%8E%B0%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B9%E6%B3%95/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>如何更新Visio文档中的模具</h2></header><div class=entry-content><p>在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。
尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。
本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。
拖拽背后的故事 当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。） 当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。
这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。
手动更新 要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。
使用COM批量更新 借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。
要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：
public IEnumerable&lt;IVShape> GetInstances(IVMaster master) { var instances = document.Pages.OfType&lt;IVPage>() .SelectMany(x => x.Shapes.OfType&lt;IVShape>()).Where(x => x.Master == master).ToList(); return instances; } 要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。
关键代码：
public IVMaster GetLatestMaster(IVDocument document, string baseID) { var latestMaster = document.Masters.OfType&lt;IVMaster>() .SingleOrDefault(x => x.BaseID == baseID); return latestMaster; } 然后，遍历这些事例，并将形状替换为新版本的模具。
public void Replace(IEnumerable&lt;IVShape> instances, IVMaster latestMaster) { foreach (var instance in instances) { instance.ReplaceShape(latestMaster); } } 使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。
另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。
使用OpenXML批量更新 当不要求在原文件中完成更新时，可以考虑直接修改OpenXML文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为".vsdx"。要查看OpenXML格式的详细内容，可以修改文档后缀为".zip"后打开压缩包。
.\visio\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。
其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考以编程方式处理Visio文件格式):
public IEnumerable&lt;XlElement> GetMasterElements(Package package) { // mastersPart指masters.xml var mastersPart = package.GetPart(XmlHelper.MastersPartUri); // 筛选出BaseID属性为baseID的Master节点 var masterElements = XmlHelper.GetXElementsByName(mastersPart, "Master"). return masterElements; } public PackagePart GetMasterContentsFile(Package package, string baseID){ var masterElement = GetMasterElement(package).SingleOrDefault(x=>x.Attribute("BaseID")!.Value == baseID); // 通过子节点Rel获取r:id var relElement = masterElement.Descendants(XmlHelper.MainNs + "Rel").First(); var relId = relElement.Attribute(XmlHelper.RelNs + "id")!.Value; var rel = mastersPart.GetRelationship(relId); // masterPart指master{i}.xml var masterPart = package.GetPart(PackUriHelper.ResolvePartUri(rel.SourceUri, rel.TargetUri)); return masterPart; } 当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：
public void Replace(Package drawingDoc, Package stencilDoc, string baseID){ var mastersPartDrawing = sourcePackage.GetPart(XmlHelper.MastersPartUri); foreach (var masterEleDrawing in GetMasterElements(drawingDoc)) { // 查看模具库中是否存在对应的Master var masterEleStencil = GetMasterElements(stencilDoc).SingleOrDefault(x=>x.Attribute("BaseID")!.Value == baseID); if (masterEleStencil == null) continue; // 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点 var relEleDrawing = masterEleDrawing.Descendants(XmlHelper.MainNs + "Rel").First(); masterEleStencil.Descendants(XmlHelper.MainNs + "Rel").First().ReplaceWith(relEleDrawing); masterEleDrawing.ReplaceWith(masterEleStencil); // 替换MasterContents var contentsPartDrawing = GetMasterContentsFile(drawingDoc, baseID); var contentsPartStencil = GetMasterContentsFile(stencilDoc, baseID); XmlHelper.SaveXDocumentToPart(contentsPartDrawing, XmlHelper.GetXmlFromPart(contentsPartStencil)); } XmlHelper.RecalculateDocument(drawingDoc); XmlHelper.SaveXDocumentToPart(mastersPartDrawing, XmlHelper.GetXmlFromPart(mastersPartDrawing)); } 查看完整代码</p></div><footer class=entry-footer><span title='2023-12-25 11:33:58 +0800 CST'>December 25, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;201 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to 如何更新Visio文档中的模具" href=http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0visio%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%85%B7/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>解决Visio使用Shape Replace方法显示OBJ的BUG 2</h2></header><div class=entry-content><p>很不幸，又遇到了同样的问题。但这次问题涉及到一个容器对象，该容器内的某个形状链接了容器的某个属性值。当使用Shape.Replace()方法进行更新时，该属性又被更新成“OBJ”。
因此，按照之前提到的方法，我们首先删除了我们自定义的容器的基本属性，例如SelectMode、DisplayMode、CalWH等。然后重新执行更新程序。此时，“OBJ”被正确的属性值所取代。
通过Visio应用程序的编辑模具功能，重新定义先前的基本属性，再次执行更新程序。不幸的是OBJ又出现了。
最终我们发现，当同时满足以下两个条件时，会产生上述的BUG：
IsTextEditTarget=False GlueType=8</p></div><footer class=entry-footer><span title='2023-10-11 14:37:16 +0800 CST'>October 11, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;6 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to 解决Visio使用Shape Replace方法显示OBJ的BUG 2" href=http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E4%BD%BF%E7%94%A8shape-replace%E6%96%B9%E6%B3%95%E6%98%BE%E7%A4%BAobj%E7%9A%84bug-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>解决Visio使用Shape Replace方法显示OBJ的BUG</h2></header><div class=entry-content><p>引言 许多Visio管理员在项目初期都会面临模具频繁更新的问题。由于Visio的机制，每当用户首次从模具库中拖拽模具至绘图页时，实际上是从该模具库中拷贝了模具的副本至文档模具中。这种机制无疑切断了文档模具与原模具库的联系，也造成管理更新模具库后无法将更新应用到已有的绘图上。当绘图上需要更新的形状数量较少时，可以使用Visio提供的更改形状功能手动更新。但是，当绘图页中存在大量的待更新形状时，使用使用程序进行批量更新。
程序批量更新的方法是遍历文档模具，并通过文档模具中模具的BaseID从模具库中找到源模具，再比较两者的UniqueID是否一致。若UniqueID一致，说明该模具没有更新，应跳过操作；若不一致，说明源模具发生了更新。然后在绘图页中找到所有与该模具关联的形状，然后删除文档模具中的旧模具，再执行Shape.Replace()方法使用新的模具替换形状。
这种方法通常是凑效的，但是在上一周中，我遇到了如下的BUG：更新后的形状显示Obj文本。仔细查看形状shapesheet，可以发现模具中已经定义好的TextField在形状中变成了空白，造成显示错误。
不幸的是，未能在Google中搜到类似的问题反馈。
问题排查 通过查看xml文件，发现该形状的Field节被替换为了&lt;Row IX='0' Del='1'/>。对比未出现显示错误的形状的xml文件可以发现：当TextField取值为空时，Field节应该继承自模具，因此xml文档不应出现Field节；当TextField存在取值时，Row节点内应该有Cell节点。此时，如果手动删除Field节，显示的OBJ文字消失。由此可以推出Field节数据发生了异常。
但是，仍然无法确定该异常的产生是因为形状定义错误还是其他。
回到Visio应用程序中，在源模具中的形状树中删除发生该问题的子形状，再次执行更新程序，原本没有问题的子形状的TextField出现同样的问题。重复执行删除子形状并更新的操作，问题始终出现。当所有的子形状都被删除后，更新后的形状不再显示OBJ。但是，新的问题出现了：形状显示数字3。显然我们并没有在模具的任何形状或子形状中定义过这个数值。
由此可以推出，形状定义并没有问题，而是其他数据导致了Visio更新时的异常行为。
为了确定是哪一部分数据存在问题，我们清空了User、ShapeData等全部用于定义用户数据的Section，问题依然复现。现在，只剩模具的基础数据了（诸如PinX、PinY等Shape节点下的Cell节点）。由于Visio中不能删除基础数据，所以在XML文件中用其他正常模具的基础数据替换问题模具的基础数据。此后，再使用程序对绘图页的形状进行更新，数字3不再出现，也就是这个BUG被修复了。
通过文本对比工具，我们比较了问题模具与正常模具的基础数据。
（此处，因为重启电脑图丢了。。。。。）
比较两者的基础数据并没有特别的地方，除了尺寸和定位存在数值差异外，只有Cell的顺序存在区别。最终也无法确定这个问题到底是怎么产生的。
解决方法 尽管未能找到该问题形成的原因，但通过定位问题位置，我们找到了解决该问题的方法：即使用正常模具的基础数据覆盖问题模具。</p></div><footer class=entry-footer><span title='2023-09-26 09:51:47 +0800 CST'>September 26, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;18 words&nbsp;·&nbsp;Snailya</footer><a class=entry-link aria-label="post link to 解决Visio使用Shape Replace方法显示OBJ的BUG" href=http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E4%BD%BF%E7%94%A8shape-replace%E6%96%B9%E6%B3%95%E6%98%BE%E7%A4%BAobj%E7%9A%84bug/></a></article><footer class=page-footer><nav class=pagination><a class=next href=http://localhost:1313/posts/page/2/>Next&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Snailya虾啵啵</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>