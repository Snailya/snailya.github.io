<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>如何更新Visio文档中的模具 | Snailya虾啵啵</title>
<meta name=keywords content><meta name=description content='在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。
尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。
本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。
拖拽背后的故事
当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。）
当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。
这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。
手动更新
要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。

使用COM批量更新
借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。
要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：
public IEnumerable<IVShape> GetInstances(IVMaster master) {
    var instances = document.Pages.OfType<IVPage>()
        .SelectMany(x => x.Shapes.OfType<IVShape>()).Where(x => x.Master == master).ToList();
    return instances;
}
要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。
关键代码：
public IVMaster GetLatestMaster(IVDocument document, string baseID) {
    var latestMaster = document.Masters.OfType<IVMaster>()
        .SingleOrDefault(x => x.BaseID == baseID);
    return latestMaster;
}
然后，遍历这些事例，并将形状替换为新版本的模具。
public void Replace(IEnumerable<IVShape> instances, IVMaster latestMaster) {
    foreach (var instance in instances) {
        instance.ReplaceShape(latestMaster);
    }
}
使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。
另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。
使用OpenXML批量更新
当不要求在原文件中完成更新时，可以考虑直接修改OpenXML文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为".vsdx"。要查看OpenXML格式的详细内容，可以修改文档后缀为".zip"后打开压缩包。

.\visio\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。


其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考以编程方式处理Visio文件格式):
public IEnumerable<XlElement> GetMasterElements(Package package) {
    // mastersPart指masters.xml
    var mastersPart = package.GetPart(XmlHelper.MastersPartUri);

    // 筛选出BaseID属性为baseID的Master节点
    var masterElements = XmlHelper.GetXElementsByName(mastersPart, "Master").

    return masterElements;
}

public PackagePart GetMasterContentsFile(Package package, string baseID){
    var masterElement = GetMasterElement(package).SingleOrDefault(x=>x.Attribute("BaseID")!.Value == baseID);

    // 通过子节点Rel获取r:id
    var relElement = masterElement.Descendants(XmlHelper.MainNs + "Rel").First();
    var relId = relElement.Attribute(XmlHelper.RelNs + "id")!.Value;
    var rel = mastersPart.GetRelationship(relId);

    // masterPart指master{i}.xml
    var masterPart = package.GetPart(PackUriHelper.ResolvePartUri(rel.SourceUri, rel.TargetUri));
    return masterPart;
}
当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：
public void Replace(Package drawingDoc, Package stencilDoc, string baseID){
    var mastersPartDrawing = sourcePackage.GetPart(XmlHelper.MastersPartUri);

    foreach (var masterEleDrawing in GetMasterElements(drawingDoc)) {
        // 查看模具库中是否存在对应的Master
        var masterEleStencil = GetMasterElements(stencilDoc).SingleOrDefault(x=>x.Attribute("BaseID")!.Value == baseID);
        if (masterEleStencil == null) continue;

        // 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点
        var relEleDrawing = masterEleDrawing.Descendants(XmlHelper.MainNs + "Rel").First();
        masterEleStencil.Descendants(XmlHelper.MainNs + "Rel").First().ReplaceWith(relEleDrawing);
        masterEleDrawing.ReplaceWith(masterEleStencil);

        // 替换MasterContents
        var contentsPartDrawing = GetMasterContentsFile(drawingDoc, baseID);
        var contentsPartStencil = GetMasterContentsFile(stencilDoc, baseID);
        XmlHelper.SaveXDocumentToPart(contentsPartDrawing, XmlHelper.GetXmlFromPart(contentsPartStencil));
    }

    XmlHelper.RecalculateDocument(drawingDoc);
    XmlHelper.SaveXDocumentToPart(mastersPartDrawing, XmlHelper.GetXmlFromPart(mastersPartDrawing));
}
查看完整代码'><meta name=author content="Snailya"><link rel=canonical href=http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0visio%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%85%B7/><meta name=google-site-verification content="_nlVQH6tLVYCE2QdNfIoFucl_5aGPyN1U8HOag0GDZg"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6da9a63d25a9608bca2f7f907a030e887a7dd3c3f3918e4cc113129361414bda.css integrity="sha256-bammPSWpYIvKL3+QegMOiHp908PzkY5MwRMSk2FBS9o=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0visio%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%85%B7/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-3LD1SQETXX"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-3LD1SQETXX")}</script><meta property="og:url" content="http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0visio%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%85%B7/"><meta property="og:site_name" content="Snailya虾啵啵"><meta property="og:title" content="如何更新Visio文档中的模具"><meta property="og:description" content='在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。
尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。
本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。
拖拽背后的故事 当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。） 当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。
这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。
手动更新 要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。
使用COM批量更新 借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。
要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：
public IEnumerable<IVShape> GetInstances(IVMaster master) { var instances = document.Pages.OfType<IVPage>() .SelectMany(x => x.Shapes.OfType<IVShape>()).Where(x => x.Master == master).ToList(); return instances; } 要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。
关键代码：
public IVMaster GetLatestMaster(IVDocument document, string baseID) { var latestMaster = document.Masters.OfType<IVMaster>() .SingleOrDefault(x => x.BaseID == baseID); return latestMaster; } 然后，遍历这些事例，并将形状替换为新版本的模具。
public void Replace(IEnumerable<IVShape> instances, IVMaster latestMaster) { foreach (var instance in instances) { instance.ReplaceShape(latestMaster); } } 使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。
另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。
使用OpenXML批量更新 当不要求在原文件中完成更新时，可以考虑直接修改OpenXML文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为".vsdx"。要查看OpenXML格式的详细内容，可以修改文档后缀为".zip"后打开压缩包。
.\visio\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。
其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考以编程方式处理Visio文件格式):
public IEnumerable<XlElement> GetMasterElements(Package package) { // mastersPart指masters.xml var mastersPart = package.GetPart(XmlHelper.MastersPartUri); // 筛选出BaseID属性为baseID的Master节点 var masterElements = XmlHelper.GetXElementsByName(mastersPart, "Master"). return masterElements; } public PackagePart GetMasterContentsFile(Package package, string baseID){ var masterElement = GetMasterElement(package).SingleOrDefault(x=>x.Attribute("BaseID")!.Value == baseID); // 通过子节点Rel获取r:id var relElement = masterElement.Descendants(XmlHelper.MainNs + "Rel").First(); var relId = relElement.Attribute(XmlHelper.RelNs + "id")!.Value; var rel = mastersPart.GetRelationship(relId); // masterPart指master{i}.xml var masterPart = package.GetPart(PackUriHelper.ResolvePartUri(rel.SourceUri, rel.TargetUri)); return masterPart; } 当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：
public void Replace(Package drawingDoc, Package stencilDoc, string baseID){ var mastersPartDrawing = sourcePackage.GetPart(XmlHelper.MastersPartUri); foreach (var masterEleDrawing in GetMasterElements(drawingDoc)) { // 查看模具库中是否存在对应的Master var masterEleStencil = GetMasterElements(stencilDoc).SingleOrDefault(x=>x.Attribute("BaseID")!.Value == baseID); if (masterEleStencil == null) continue; // 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点 var relEleDrawing = masterEleDrawing.Descendants(XmlHelper.MainNs + "Rel").First(); masterEleStencil.Descendants(XmlHelper.MainNs + "Rel").First().ReplaceWith(relEleDrawing); masterEleDrawing.ReplaceWith(masterEleStencil); // 替换MasterContents var contentsPartDrawing = GetMasterContentsFile(drawingDoc, baseID); var contentsPartStencil = GetMasterContentsFile(stencilDoc, baseID); XmlHelper.SaveXDocumentToPart(contentsPartDrawing, XmlHelper.GetXmlFromPart(contentsPartStencil)); } XmlHelper.RecalculateDocument(drawingDoc); XmlHelper.SaveXDocumentToPart(mastersPartDrawing, XmlHelper.GetXmlFromPart(mastersPartDrawing)); } 查看完整代码'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-25T11:33:58+08:00"><meta property="article:modified_time" content="2023-12-25T11:33:58+08:00"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="如何更新Visio文档中的模具"><meta name=twitter:description content='在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。
尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。
本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。
拖拽背后的故事
当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。）
当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。
这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。
手动更新
要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。

使用COM批量更新
借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。
要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：
public IEnumerable<IVShape> GetInstances(IVMaster master) {
    var instances = document.Pages.OfType<IVPage>()
        .SelectMany(x => x.Shapes.OfType<IVShape>()).Where(x => x.Master == master).ToList();
    return instances;
}
要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。
关键代码：
public IVMaster GetLatestMaster(IVDocument document, string baseID) {
    var latestMaster = document.Masters.OfType<IVMaster>()
        .SingleOrDefault(x => x.BaseID == baseID);
    return latestMaster;
}
然后，遍历这些事例，并将形状替换为新版本的模具。
public void Replace(IEnumerable<IVShape> instances, IVMaster latestMaster) {
    foreach (var instance in instances) {
        instance.ReplaceShape(latestMaster);
    }
}
使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。
另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。
使用OpenXML批量更新
当不要求在原文件中完成更新时，可以考虑直接修改OpenXML文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为".vsdx"。要查看OpenXML格式的详细内容，可以修改文档后缀为".zip"后打开压缩包。

.\visio\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。


其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考以编程方式处理Visio文件格式):
public IEnumerable<XlElement> GetMasterElements(Package package) {
    // mastersPart指masters.xml
    var mastersPart = package.GetPart(XmlHelper.MastersPartUri);

    // 筛选出BaseID属性为baseID的Master节点
    var masterElements = XmlHelper.GetXElementsByName(mastersPart, "Master").

    return masterElements;
}

public PackagePart GetMasterContentsFile(Package package, string baseID){
    var masterElement = GetMasterElement(package).SingleOrDefault(x=>x.Attribute("BaseID")!.Value == baseID);

    // 通过子节点Rel获取r:id
    var relElement = masterElement.Descendants(XmlHelper.MainNs + "Rel").First();
    var relId = relElement.Attribute(XmlHelper.RelNs + "id")!.Value;
    var rel = mastersPart.GetRelationship(relId);

    // masterPart指master{i}.xml
    var masterPart = package.GetPart(PackUriHelper.ResolvePartUri(rel.SourceUri, rel.TargetUri));
    return masterPart;
}
当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：
public void Replace(Package drawingDoc, Package stencilDoc, string baseID){
    var mastersPartDrawing = sourcePackage.GetPart(XmlHelper.MastersPartUri);

    foreach (var masterEleDrawing in GetMasterElements(drawingDoc)) {
        // 查看模具库中是否存在对应的Master
        var masterEleStencil = GetMasterElements(stencilDoc).SingleOrDefault(x=>x.Attribute("BaseID")!.Value == baseID);
        if (masterEleStencil == null) continue;

        // 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点
        var relEleDrawing = masterEleDrawing.Descendants(XmlHelper.MainNs + "Rel").First();
        masterEleStencil.Descendants(XmlHelper.MainNs + "Rel").First().ReplaceWith(relEleDrawing);
        masterEleDrawing.ReplaceWith(masterEleStencil);

        // 替换MasterContents
        var contentsPartDrawing = GetMasterContentsFile(drawingDoc, baseID);
        var contentsPartStencil = GetMasterContentsFile(stencilDoc, baseID);
        XmlHelper.SaveXDocumentToPart(contentsPartDrawing, XmlHelper.GetXmlFromPart(contentsPartStencil));
    }

    XmlHelper.RecalculateDocument(drawingDoc);
    XmlHelper.SaveXDocumentToPart(mastersPartDrawing, XmlHelper.GetXmlFromPart(mastersPartDrawing));
}
查看完整代码'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"如何更新Visio文档中的模具","item":"http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0visio%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%85%B7/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"如何更新Visio文档中的模具","name":"如何更新Visio文档中的模具","description":"在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。\n尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。\n本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。\n拖拽背后的故事 当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。） 当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。\n这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。\n手动更新 要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。\n使用COM批量更新 借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。\n要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：\npublic IEnumerable\u0026lt;IVShape\u0026gt; GetInstances(IVMaster master) { var instances = document.Pages.OfType\u0026lt;IVPage\u0026gt;() .SelectMany(x =\u0026gt; x.Shapes.OfType\u0026lt;IVShape\u0026gt;()).Where(x =\u0026gt; x.Master == master).ToList(); return instances; } 要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。\n关键代码：\npublic IVMaster GetLatestMaster(IVDocument document, string baseID) { var latestMaster = document.Masters.OfType\u0026lt;IVMaster\u0026gt;() .SingleOrDefault(x =\u0026gt; x.BaseID == baseID); return latestMaster; } 然后，遍历这些事例，并将形状替换为新版本的模具。\npublic void Replace(IEnumerable\u0026lt;IVShape\u0026gt; instances, IVMaster latestMaster) { foreach (var instance in instances) { instance.ReplaceShape(latestMaster); } } 使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。\n另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。\n使用OpenXML批量更新 当不要求在原文件中完成更新时，可以考虑直接修改OpenXML文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为\u0026quot;.vsdx\u0026quot;。要查看OpenXML格式的详细内容，可以修改文档后缀为\u0026quot;.zip\u0026quot;后打开压缩包。\n.\\visio\\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。\n其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考以编程方式处理Visio文件格式):\npublic IEnumerable\u0026lt;XlElement\u0026gt; GetMasterElements(Package package) { // mastersPart指masters.xml var mastersPart = package.GetPart(XmlHelper.MastersPartUri); // 筛选出BaseID属性为baseID的Master节点 var masterElements = XmlHelper.GetXElementsByName(mastersPart, \u0026#34;Master\u0026#34;). return masterElements; } public PackagePart GetMasterContentsFile(Package package, string baseID){ var masterElement = GetMasterElement(package).SingleOrDefault(x=\u0026gt;x.Attribute(\u0026#34;BaseID\u0026#34;)!.Value == baseID); // 通过子节点Rel获取r:id var relElement = masterElement.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First(); var relId = relElement.Attribute(XmlHelper.RelNs + \u0026#34;id\u0026#34;)!.Value; var rel = mastersPart.GetRelationship(relId); // masterPart指master{i}.xml var masterPart = package.GetPart(PackUriHelper.ResolvePartUri(rel.SourceUri, rel.TargetUri)); return masterPart; } 当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：\npublic void Replace(Package drawingDoc, Package stencilDoc, string baseID){ var mastersPartDrawing = sourcePackage.GetPart(XmlHelper.MastersPartUri); foreach (var masterEleDrawing in GetMasterElements(drawingDoc)) { // 查看模具库中是否存在对应的Master var masterEleStencil = GetMasterElements(stencilDoc).SingleOrDefault(x=\u0026gt;x.Attribute(\u0026#34;BaseID\u0026#34;)!.Value == baseID); if (masterEleStencil == null) continue; // 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点 var relEleDrawing = masterEleDrawing.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First(); masterEleStencil.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First().ReplaceWith(relEleDrawing); masterEleDrawing.ReplaceWith(masterEleStencil); // 替换MasterContents var contentsPartDrawing = GetMasterContentsFile(drawingDoc, baseID); var contentsPartStencil = GetMasterContentsFile(stencilDoc, baseID); XmlHelper.SaveXDocumentToPart(contentsPartDrawing, XmlHelper.GetXmlFromPart(contentsPartStencil)); } XmlHelper.RecalculateDocument(drawingDoc); XmlHelper.SaveXDocumentToPart(mastersPartDrawing, XmlHelper.GetXmlFromPart(mastersPartDrawing)); } 查看完整代码\n","keywords":[],"articleBody":"在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。\n尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。\n本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。\n拖拽背后的故事 当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。） 当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。\n这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。\n手动更新 要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。\n使用COM批量更新 借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。\n要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：\npublic IEnumerable\u003cIVShape\u003e GetInstances(IVMaster master) { var instances = document.Pages.OfType\u003cIVPage\u003e() .SelectMany(x =\u003e x.Shapes.OfType\u003cIVShape\u003e()).Where(x =\u003e x.Master == master).ToList(); return instances; } 要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。\n关键代码：\npublic IVMaster GetLatestMaster(IVDocument document, string baseID) { var latestMaster = document.Masters.OfType\u003cIVMaster\u003e() .SingleOrDefault(x =\u003e x.BaseID == baseID); return latestMaster; } 然后，遍历这些事例，并将形状替换为新版本的模具。\npublic void Replace(IEnumerable\u003cIVShape\u003e instances, IVMaster latestMaster) { foreach (var instance in instances) { instance.ReplaceShape(latestMaster); } } 使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。\n另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。\n使用OpenXML批量更新 当不要求在原文件中完成更新时，可以考虑直接修改OpenXML文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为\".vsdx\"。要查看OpenXML格式的详细内容，可以修改文档后缀为\".zip\"后打开压缩包。\n.\\visio\\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。\n其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考以编程方式处理Visio文件格式):\npublic IEnumerable\u003cXlElement\u003e GetMasterElements(Package package) { // mastersPart指masters.xml var mastersPart = package.GetPart(XmlHelper.MastersPartUri); // 筛选出BaseID属性为baseID的Master节点 var masterElements = XmlHelper.GetXElementsByName(mastersPart, \"Master\"). return masterElements; } public PackagePart GetMasterContentsFile(Package package, string baseID){ var masterElement = GetMasterElement(package).SingleOrDefault(x=\u003ex.Attribute(\"BaseID\")!.Value == baseID); // 通过子节点Rel获取r:id var relElement = masterElement.Descendants(XmlHelper.MainNs + \"Rel\").First(); var relId = relElement.Attribute(XmlHelper.RelNs + \"id\")!.Value; var rel = mastersPart.GetRelationship(relId); // masterPart指master{i}.xml var masterPart = package.GetPart(PackUriHelper.ResolvePartUri(rel.SourceUri, rel.TargetUri)); return masterPart; } 当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：\npublic void Replace(Package drawingDoc, Package stencilDoc, string baseID){ var mastersPartDrawing = sourcePackage.GetPart(XmlHelper.MastersPartUri); foreach (var masterEleDrawing in GetMasterElements(drawingDoc)) { // 查看模具库中是否存在对应的Master var masterEleStencil = GetMasterElements(stencilDoc).SingleOrDefault(x=\u003ex.Attribute(\"BaseID\")!.Value == baseID); if (masterEleStencil == null) continue; // 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点 var relEleDrawing = masterEleDrawing.Descendants(XmlHelper.MainNs + \"Rel\").First(); masterEleStencil.Descendants(XmlHelper.MainNs + \"Rel\").First().ReplaceWith(relEleDrawing); masterEleDrawing.ReplaceWith(masterEleStencil); // 替换MasterContents var contentsPartDrawing = GetMasterContentsFile(drawingDoc, baseID); var contentsPartStencil = GetMasterContentsFile(stencilDoc, baseID); XmlHelper.SaveXDocumentToPart(contentsPartDrawing, XmlHelper.GetXmlFromPart(contentsPartStencil)); } XmlHelper.RecalculateDocument(drawingDoc); XmlHelper.SaveXDocumentToPart(mastersPartDrawing, XmlHelper.GetXmlFromPart(mastersPartDrawing)); } 查看完整代码\n","wordCount":"201","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2023-12-25T11:33:58+08:00","dateModified":"2023-12-25T11:33:58+08:00","author":{"@type":"Person","name":"Snailya"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0visio%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%85%B7/"},"publisher":{"@type":"Organization","name":"Snailya虾啵啵","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Snailya虾啵啵 (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Snailya虾啵啵</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/search/ title=搜索><span>搜索</span></a></li><li><a href=http://localhost:1313/categories/ title=分类><span>分类</span></a></li><li><a href=http://localhost:1313/tags/ title=标签><span>标签</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">如何更新Visio文档中的模具</h1><div class=post-meta><span title='2023-12-25 11:33:58 +0800 CST'>December 25, 2023</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;201 words&nbsp;·&nbsp;Snailya&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/%e5%a6%82%e4%bd%95%e6%9b%b4%e6%96%b0Visio%e6%96%87%e6%a1%a3%e4%b8%ad%e7%9a%84%e6%a8%a1%e5%85%b7.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。</p><p>尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。</p><p>本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。</p><h2 id=拖拽背后的故事>拖拽背后的故事<a hidden class=anchor aria-hidden=true href=#拖拽背后的故事>#</a></h2><p><a href=https://techcommunity.microsoft.com/t5/microsoft-365-blog/drag-drop-done/ba-p/237244>当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作</a>。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。）
当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。</p><p>这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。</p><h2 id=手动更新>手动更新<a hidden class=anchor aria-hidden=true href=#手动更新>#</a></h2><p>要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。</p><p><img alt=change-shape.png loading=lazy src=https://s2.loli.net/2023/12/26/YSPq96nDTp2vEib.png></p><h2 id=使用com批量更新>使用COM批量更新<a hidden class=anchor aria-hidden=true href=#使用com批量更新>#</a></h2><p>借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。</p><p>要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>IVShape</span><span class=p>&gt;</span> <span class=n>GetInstances</span><span class=p>(</span><span class=n>IVMaster</span> <span class=n>master</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>instances</span> <span class=p>=</span> <span class=n>document</span><span class=p>.</span><span class=n>Pages</span><span class=p>.</span><span class=n>OfType</span><span class=p>&lt;</span><span class=n>IVPage</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>SelectMany</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>x</span><span class=p>.</span><span class=n>Shapes</span><span class=p>.</span><span class=n>OfType</span><span class=p>&lt;</span><span class=n>IVShape</span><span class=p>&gt;()).</span><span class=n>Where</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>x</span><span class=p>.</span><span class=n>Master</span> <span class=p>==</span> <span class=n>master</span><span class=p>).</span><span class=n>ToList</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>instances</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。</p><p>关键代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=n>IVMaster</span> <span class=n>GetLatestMaster</span><span class=p>(</span><span class=n>IVDocument</span> <span class=n>document</span><span class=p>,</span> <span class=kt>string</span> <span class=n>baseID</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>latestMaster</span> <span class=p>=</span> <span class=n>document</span><span class=p>.</span><span class=n>Masters</span><span class=p>.</span><span class=n>OfType</span><span class=p>&lt;</span><span class=n>IVMaster</span><span class=p>&gt;()</span>
</span></span><span class=line><span class=cl>        <span class=p>.</span><span class=n>SingleOrDefault</span><span class=p>(</span><span class=n>x</span> <span class=p>=&gt;</span> <span class=n>x</span><span class=p>.</span><span class=n>BaseID</span> <span class=p>==</span> <span class=n>baseID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>latestMaster</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>然后，遍历这些事例，并将形状替换为新版本的模具。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>Replace</span><span class=p>(</span><span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>IVShape</span><span class=p>&gt;</span> <span class=n>instances</span><span class=p>,</span> <span class=n>IVMaster</span> <span class=n>latestMaster</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=kt>var</span> <span class=n>instance</span> <span class=k>in</span> <span class=n>instances</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>instance</span><span class=p>.</span><span class=n>ReplaceShape</span><span class=p>(</span><span class=n>latestMaster</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。</p><p>另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。</p><h2 id=使用openxml批量更新>使用OpenXML批量更新<a hidden class=anchor aria-hidden=true href=#使用openxml批量更新>#</a></h2><p>当不要求在原文件中完成更新时，可以考虑直接修改<a href=https://learn.microsoft.com/en-us/office/client-developer/visio/introduction-to-the-visio-file-formatvsdx>OpenXML</a>文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为".vsdx"。要查看OpenXML格式的详细内容，可以修改文档后缀为".zip"后打开压缩包。</p><p><img alt=open-vsdx-as-zip.png loading=lazy src=https://s2.loli.net/2023/12/26/1dKCDJwfYpV6B79.png></p><p>.\visio\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。</p><p><img alt=master.png loading=lazy src=https://s2.loli.net/2023/12/26/BLtjEZDhK4a3crA.png></p><p><img alt=master-content.png loading=lazy src=https://s2.loli.net/2023/12/26/38Wx795LYotHfdk.png></p><p>其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考<a href=https://learn.microsoft.com/en-us/office/client-developer/visio/how-to-manipulate-the-visio-file-format-programmatically>以编程方式处理Visio文件格式</a>):</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=n>IEnumerable</span><span class=p>&lt;</span><span class=n>XlElement</span><span class=p>&gt;</span> <span class=n>GetMasterElements</span><span class=p>(</span><span class=n>Package</span> <span class=n>package</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// mastersPart指masters.xml</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>mastersPart</span> <span class=p>=</span> <span class=n>package</span><span class=p>.</span><span class=n>GetPart</span><span class=p>(</span><span class=n>XmlHelper</span><span class=p>.</span><span class=n>MastersPartUri</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 筛选出BaseID属性为baseID的Master节点</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>masterElements</span> <span class=p>=</span> <span class=n>XmlHelper</span><span class=p>.</span><span class=n>GetXElementsByName</span><span class=p>(</span><span class=n>mastersPart</span><span class=p>,</span> <span class=s>&#34;Master&#34;</span><span class=p>).</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>masterElements</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=n>PackagePart</span> <span class=n>GetMasterContentsFile</span><span class=p>(</span><span class=n>Package</span> <span class=n>package</span><span class=p>,</span> <span class=kt>string</span> <span class=n>baseID</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>masterElement</span> <span class=p>=</span> <span class=n>GetMasterElement</span><span class=p>(</span><span class=n>package</span><span class=p>).</span><span class=n>SingleOrDefault</span><span class=p>(</span><span class=n>x</span><span class=p>=&gt;</span><span class=n>x</span><span class=p>.</span><span class=n>Attribute</span><span class=p>(</span><span class=s>&#34;BaseID&#34;</span><span class=p>)!.</span><span class=n>Value</span> <span class=p>==</span> <span class=n>baseID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 通过子节点Rel获取r:id</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>relElement</span> <span class=p>=</span> <span class=n>masterElement</span><span class=p>.</span><span class=n>Descendants</span><span class=p>(</span><span class=n>XmlHelper</span><span class=p>.</span><span class=n>MainNs</span> <span class=p>+</span> <span class=s>&#34;Rel&#34;</span><span class=p>).</span><span class=n>First</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>relId</span> <span class=p>=</span> <span class=n>relElement</span><span class=p>.</span><span class=n>Attribute</span><span class=p>(</span><span class=n>XmlHelper</span><span class=p>.</span><span class=n>RelNs</span> <span class=p>+</span> <span class=s>&#34;id&#34;</span><span class=p>)!.</span><span class=n>Value</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>rel</span> <span class=p>=</span> <span class=n>mastersPart</span><span class=p>.</span><span class=n>GetRelationship</span><span class=p>(</span><span class=n>relId</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// masterPart指master{i}.xml</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>masterPart</span> <span class=p>=</span> <span class=n>package</span><span class=p>.</span><span class=n>GetPart</span><span class=p>(</span><span class=n>PackUriHelper</span><span class=p>.</span><span class=n>ResolvePartUri</span><span class=p>(</span><span class=n>rel</span><span class=p>.</span><span class=n>SourceUri</span><span class=p>,</span> <span class=n>rel</span><span class=p>.</span><span class=n>TargetUri</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>masterPart</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C# data-lang=C#><span class=line><span class=cl><span class=kd>public</span> <span class=k>void</span> <span class=n>Replace</span><span class=p>(</span><span class=n>Package</span> <span class=n>drawingDoc</span><span class=p>,</span> <span class=n>Package</span> <span class=n>stencilDoc</span><span class=p>,</span> <span class=kt>string</span> <span class=n>baseID</span><span class=p>){</span>
</span></span><span class=line><span class=cl>    <span class=kt>var</span> <span class=n>mastersPartDrawing</span> <span class=p>=</span> <span class=n>sourcePackage</span><span class=p>.</span><span class=n>GetPart</span><span class=p>(</span><span class=n>XmlHelper</span><span class=p>.</span><span class=n>MastersPartUri</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>foreach</span> <span class=p>(</span><span class=kt>var</span> <span class=n>masterEleDrawing</span> <span class=k>in</span> <span class=n>GetMasterElements</span><span class=p>(</span><span class=n>drawingDoc</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 查看模具库中是否存在对应的Master</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>masterEleStencil</span> <span class=p>=</span> <span class=n>GetMasterElements</span><span class=p>(</span><span class=n>stencilDoc</span><span class=p>).</span><span class=n>SingleOrDefault</span><span class=p>(</span><span class=n>x</span><span class=p>=&gt;</span><span class=n>x</span><span class=p>.</span><span class=n>Attribute</span><span class=p>(</span><span class=s>&#34;BaseID&#34;</span><span class=p>)!.</span><span class=n>Value</span> <span class=p>==</span> <span class=n>baseID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>masterEleStencil</span> <span class=p>==</span> <span class=kc>null</span><span class=p>)</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>relEleDrawing</span> <span class=p>=</span> <span class=n>masterEleDrawing</span><span class=p>.</span><span class=n>Descendants</span><span class=p>(</span><span class=n>XmlHelper</span><span class=p>.</span><span class=n>MainNs</span> <span class=p>+</span> <span class=s>&#34;Rel&#34;</span><span class=p>).</span><span class=n>First</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=n>masterEleStencil</span><span class=p>.</span><span class=n>Descendants</span><span class=p>(</span><span class=n>XmlHelper</span><span class=p>.</span><span class=n>MainNs</span> <span class=p>+</span> <span class=s>&#34;Rel&#34;</span><span class=p>).</span><span class=n>First</span><span class=p>().</span><span class=n>ReplaceWith</span><span class=p>(</span><span class=n>relEleDrawing</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>masterEleDrawing</span><span class=p>.</span><span class=n>ReplaceWith</span><span class=p>(</span><span class=n>masterEleStencil</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// 替换MasterContents</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>contentsPartDrawing</span> <span class=p>=</span> <span class=n>GetMasterContentsFile</span><span class=p>(</span><span class=n>drawingDoc</span><span class=p>,</span> <span class=n>baseID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>var</span> <span class=n>contentsPartStencil</span> <span class=p>=</span> <span class=n>GetMasterContentsFile</span><span class=p>(</span><span class=n>stencilDoc</span><span class=p>,</span> <span class=n>baseID</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>XmlHelper</span><span class=p>.</span><span class=n>SaveXDocumentToPart</span><span class=p>(</span><span class=n>contentsPartDrawing</span><span class=p>,</span> <span class=n>XmlHelper</span><span class=p>.</span><span class=n>GetXmlFromPart</span><span class=p>(</span><span class=n>contentsPartStencil</span><span class=p>));</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>XmlHelper</span><span class=p>.</span><span class=n>RecalculateDocument</span><span class=p>(</span><span class=n>drawingDoc</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>XmlHelper</span><span class=p>.</span><span class=n>SaveXDocumentToPart</span><span class=p>(</span><span class=n>mastersPartDrawing</span><span class=p>,</span> <span class=n>XmlHelper</span><span class=p>.</span><span class=n>GetXmlFromPart</span><span class=p>(</span><span class=n>mastersPartDrawing</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p><a href=https://github.com/Snailya/AE.PID/blob/main/PID.VisioAddIn/Controllers/Services/DocumentUpdater.cs>查看完整代码</a></p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/visual-studio-installer%E5%AE%9E%E7%8E%B0%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B9%E6%B3%95/><span class=title>« Prev</span><br><span>Visual Studio Installer实现覆盖安装新版本的方法</span>
</a><a class=next href=http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E4%BD%BF%E7%94%A8shape-replace%E6%96%B9%E6%B3%95%E6%98%BE%E7%A4%BAobj%E7%9A%84bug-2/><span class=title>Next »</span><br><span>解决Visio使用Shape Replace方法显示OBJ的BUG 2</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=Snailya/snailya.github.io data-repo-id=R_kgDOLDeIag data-category=Announcements data-category-id=DIC_kwDOLDeIas4CcWGj data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>Snailya虾啵啵</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>