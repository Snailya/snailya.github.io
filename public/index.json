[{"content":"许多.NET桌面开发者习惯使用WPF开发用户界面。然而，在VSTO应用程序中使用WPF时，与传统桌面开发相比，必须正确设置线程以防止UI阻塞。\n在传统桌面开发中，UI线程即是主线程。因此，我们通常在主线程中实例化Window并调用Show()方法来显示Window。但在VSTO应用程序中，主线程是VSTO_Main线程, Office外接程序将在VSTO_Main中通过COM组件访问Office中的数据以及执行操作。如果在该线程中实例化Window，那么所有用户与Window的交互及程序对COM组件的调用都将共享此线程。试想一下，如果我们打算在Window中展示Office中已有的数据，并在加载数据过程中显示等待动画，此时Window和数据读取程序将轮流使用VSTO_Main线程。当读取数据时，等待动画必须等待数据读取完成才能刷新界面，所以我们会看到等待动画卡顿。\n为了解决这个问题，开发者可能会尝试将所有对COM组件的调用放在TaskPool中。然而，由于Office应用程序的单线程单元（STA）特性，在后台线程中调用COM组件会显著影响性能。例如，在一个程序中，需要读取Visio页面中的约300个形状并显示在UI中。如果在VSTO_Main线程中执行读取操作，约需10秒钟；而在后台线程中执行则需要约2分钟。这是因为后台线程在访问COM组件时，需要进行对象封送处理，极大降低了效率。\n因此，最佳的解决方案是为WPF页面创建独立的线程。这可以通过以下步骤实现：\n创建新线程：在新线程中实例化WPF窗口。 设置线程属性：确保新线程为STA线程，并启动消息循环。 管理线程间通信：通过Dispatcher将COM相关操作放在VSTO_Main中进行。 这样可以避免在主线程中进行繁重的UI操作，同时保持对COM组件的高效访问。 public partial class ThisAddIn { public static Dispatcher? VSTODispatcher { get; private set; } public static Dispatcher? UIDispatcher { get; private set; } private void ThisAddIn_Startup(object sender, System.EventArgs e) { // 记录下VSTO_Main线程的Dispatcher，以方便将相COM操作放在VSTO_Main中执行 VSTODispatcher = Dispatcher.CurrentDispatcher; // declare a UI thread to display wpf window var uiThread = new Thread(()=\u0026gt;{ // 记录下UI线程的Dispatcher，以方便在VSTO_Main线程中更新UI UIDispatcher = Dispatcher.CurrentDispatcher; var window = new MainWindow(); window.Show(); // 开启消息循环 System.Windows.Threading.Dispatcher.Run(); }) { Name = \u0026#34;UI Thread\u0026#34; }; // 设置新线程为单线程套间 uiThread.SetApartmentState(ApartmentState.STA); // 启动线程 uiThread.Start(); } // other codes } 现在，我们可以按照传统桌面程序开发的方式，将复杂且耗时的任务放在TaskPool或ThreadPool中执行。当需要访问COM数据或调用COM接口时，通过VSTODispatcher.Invoke()和InvokeAsnyc()方法将部分代码切换到VSTO_Main线程中执行。\npublic async Task SomeTask(){ // 一些简单的耗时操作但是不使用到COM ... // 耗时操作需要从COM返回数据 var shapes = await VSTODispatcher.InvokeAsync(()=\u0026gt;{ return Globals.ThisAddIn.Application.ActivePage.Shapes.OfType\u0026lt;Shape\u0026gt;().Select(x=\u0026gt; new MyShape(x)).ToList(); }) UIDispatcher.Invoke(()=\u0026gt;{ // 更新UI ... }) } 这样做的好处在于可以充分利用多线程的优势，将繁重的计算和数据处理任务放在后台线程中进行，减少主线程的负载，提高应用程序的响应速度。同时，通过VSTODispatcher.Invoke()方法，可以确保COM数据访问和接口调用在主线程中进行，避免因线程切换而导致的性能问题。\n","permalink":"http://localhost:1313/posts/%E5%9C%A8vsto%E4%B8%AD%E4%BD%BF%E7%94%A8wpf%E8%BF%9B%E8%A1%8C%E7%94%A8%E6%88%B7%E4%BA%A4%E4%BA%92%E6%97%B6%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%AE%BE%E7%BD%AE/","summary":"\u003cp\u003e许多.NET桌面开发者习惯使用WPF开发用户界面。然而，在VSTO应用程序中使用WPF时，与传统桌面开发相比，必须正确设置线程以防止UI阻塞。\u003c/p\u003e\n\u003cp\u003e在传统桌面开发中，UI线程即是主线程。因此，我们通常在主线程中实例化Window并调用Show()方法来显示Window。但在VSTO应用程序中，主线程是VSTO_Main线程, Office外接程序将在VSTO_Main中通过COM组件访问Office中的数据以及执行操作。如果在该线程中实例化Window，那么所有用户与Window的交互及程序对COM组件的调用都将共享此线程。试想一下，如果我们打算在Window中展示Office中已有的数据，并在加载数据过程中显示等待动画，此时Window和数据读取程序将轮流使用VSTO_Main线程。当读取数据时，等待动画必须等待数据读取完成才能刷新界面，所以我们会看到等待动画卡顿。\u003c/p\u003e\n\u003cp\u003e为了解决这个问题，开发者可能会尝试将所有对COM组件的调用放在TaskPool中。然而，由于Office应用程序的单线程单元（STA）特性，在后台线程中调用COM组件会显著影响性能。例如，在一个程序中，需要读取Visio页面中的约300个形状并显示在UI中。如果在VSTO_Main线程中执行读取操作，约需10秒钟；而在后台线程中执行则需要约2分钟。这是因为后台线程在访问COM组件时，需要进行对象封送处理，极大降低了效率。\u003c/p\u003e\n\u003cp\u003e因此，最佳的解决方案是为WPF页面创建独立的线程。这可以通过以下步骤实现：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建新线程：在新线程中实例化WPF窗口。\u003c/li\u003e\n\u003cli\u003e设置线程属性：确保新线程为STA线程，并启动消息循环。\u003c/li\u003e\n\u003cli\u003e管理线程间通信：通过Dispatcher将COM相关操作放在VSTO_Main中进行。\n这样可以避免在主线程中进行繁重的UI操作，同时保持对COM组件的高效访问。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-CSharp\" data-lang=\"CSharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003epartial\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eThisAddIn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003eDispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e?\u003c/span\u003e \u003cspan class=\"n\"\u003eVSTODispatcher\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003eset\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003eDispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e?\u003c/span\u003e \u003cspan class=\"n\"\u003eUIDispatcher\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"k\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003eset\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eThisAddIn_Startup\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 记录下VSTO_Main线程的Dispatcher，以方便将相COM操作放在VSTO_Main中执行\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eVSTODispatcher\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eDispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentDispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// declare a UI thread to display wpf window\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003euiThread\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e(()=\u0026gt;{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e// 记录下UI线程的Dispatcher，以方便在VSTO_Main线程中更新UI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eUIDispatcher\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eDispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eCurrentDispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003ewindow\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eMainWindow\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003ewindow\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eShow\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"c1\"\u003e// 开启消息循环\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                \u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWindows\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eThreading\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRun\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e})\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e \u003cspan class=\"n\"\u003eName\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;UI Thread\u0026#34;\u003c/span\u003e \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 设置新线程为单线程套间\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003euiThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSetApartmentState\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eApartmentState\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSTA\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 启动线程\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003euiThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eStart\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// other codes\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e现在，我们可以按照传统桌面程序开发的方式，将复杂且耗时的任务放在TaskPool或ThreadPool中执行。当需要访问COM数据或调用COM接口时，通过\u003ccode\u003eVSTODispatcher.Invoke()\u003c/code\u003e和\u003ccode\u003eInvokeAsnyc()\u003c/code\u003e方法将部分代码切换到VSTO_Main线程中执行。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-CSharp\" data-lang=\"CSharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003easync\u003c/span\u003e \u003cspan class=\"n\"\u003eTask\u003c/span\u003e \u003cspan class=\"n\"\u003eSomeTask\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 一些简单的耗时操作但是不使用到COM\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 耗时操作需要从COM返回数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003eshapes\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003eawait\u003c/span\u003e \u003cspan class=\"n\"\u003eVSTODispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eInvokeAsync\u003c/span\u003e\u003cspan class=\"p\"\u003e(()=\u0026gt;{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003eGlobals\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eThisAddIn\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eApplication\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eActivePage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eShapes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOfType\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eShape\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;().\u003c/span\u003e\u003cspan class=\"n\"\u003eSelect\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eMyShape\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e)).\u003c/span\u003e\u003cspan class=\"n\"\u003eToList\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eUIDispatcher\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eInvoke\u003c/span\u003e\u003cspan class=\"p\"\u003e(()=\u0026gt;{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 更新UI\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e...\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e这样做的好处在于可以充分利用多线程的优势，将繁重的计算和数据处理任务放在后台线程中进行，减少主线程的负载，提高应用程序的响应速度。同时，通过VSTODispatcher.Invoke()方法，可以确保COM数据访问和接口调用在主线程中进行，避免因线程切换而导致的性能问题。\u003c/p\u003e","title":"在VSTO中使用WPF进行用户交互时的线程设置"},{"content":"本文以中涂洁净间循环风机为例介绍AE PID绘制设备原理图的基本流程。\n详细步骤 在Visio中使用空白模板创建新的绘图，单位选择“公制单位”；\n在功能区处切换至AE PID选项卡；\n点击“编辑”-“初始化”按钮对当前绘图进行初始化。初始化操作将在当前页面中插入一个A0图框，并设置文档页面的网格宽度为2.5 mm。\n此外，为文档增加2个AE指定样式。其中，“AE Normal”样式是设备单元的默认样式，“AE Pipeline”是管线的默认样式。\nAE样式将使用“思源黑体”作为指定字体，在AE PID插件的安装过程中会自动为系统安装思源黑体。若未能正确显示思源黑体，请尝试手动安装。\n若要修改图框大小，用鼠标右键点击图框，并在子类中选择合适的尺寸;\n在选项卡中点击“编辑”-“库”加载模具库。\n从“AE逻辑”库中拖拽“功能单元”至绘图区；\n当您不确定所需的设备对象属于哪一个类型时，可以借助Visio模具的搜索栏进行搜索。这将帮助您快速找到所需的设备对象，无需事先知道其具体类型。\n如果您正在使用Windows11系统，搜索功能可能未能如期使用，请按照修复了Visio桌面应用中的形状Windows 11的方法修补。\n用鼠标右键点击该“功能单元”，打开“形状数据”面板;\n在“形状数据”面板中输入“功能组”值：“GF612”，“功能组名称”值：“中途洁净间循环风机”；\n此时，功能单元显示如下：\n使用相同的方法从“AE基础”库中拖拽“鼓风机”至功能组内，此时可以看到功能单元边框被高亮为绿色，表示该风机已被加入功能单元。\n保持风机的选中状态，在“形状数据”面板中键入“功能元件”值：11，按下回车后该值将显示为“GQ11”；\n拖动GQ11上的黄色控制点，可以移动功能元件标签的位置；\n为了表示鼓风机配备的电机，从“AE逻辑”库中拖拽“代理功能元件”至功能组内；\n选中该代理功能元件，将黄色控制点拖拽至鼓风机上，使代理功能元件与鼓风机相关联；\n被关联后，代理功能元件的形状数据处可以看见被关联设备的位号；\n当被关联设备发生移动时，关联元件会跟随移动；\n保持代理功能元件的选中状态，补充“元件位号”值：“MA01”，描述：“电机”，并将代理功能元件拖拽至鼓风机附近。\n继续从“AE基础”库中拖拽“仪表”至功能单元中，并在右键菜单中选择“子类”-“本地面板监视仪表”；\n补充形状数据并将仪表移动至合适的位置；\n将仪表正中的控制点拖拽至鼓风机上；\n使用同样的方法绘制下方的“中控监视操作仪表”；\n从“AE管线”库中拖拽“管路”至绘图区，并在“子类”中选择“排出空气”使其显示为柠黄色；\n将管路一段连在鼓风机的连接点上，另一端连接至其他对象，并在右键菜单中点击“改变箭头方向”；\n多次点击直到箭头朝向如图所示；\n使用相同的方法完成另一根管路的绘制；\n在选项卡中点击“导出”-“BOM”查看当前图纸的BOM结构；\n在选项卡中点击“编辑”-“图例”将在图签上方生成图例；\n图例仅显示图纸中出现的设备。\n","permalink":"http://localhost:1313/posts/ae-pid%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","summary":"\u003cp\u003e本文以中涂洁净间循环风机为例介绍AE PID绘制设备原理图的基本流程。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"sample.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af081b38a5.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"详细步骤\"\u003e详细步骤\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e在Visio中使用空白模板创建新的绘图，单位选择“公制单位”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"create-document.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0a2acaf3.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在功能区处切换至AE PID选项卡；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"ribbon.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aede8bfb49.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e点击“编辑”-“初始化”按钮对当前绘图进行初始化。初始化操作将在当前页面中插入一个A0图框，并设置文档页面的网格宽度为2.5 mm。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"frame-and-grid.png.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aefb4cb37f.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此外，为文档增加2个AE指定样式。其中，“AE Normal”样式是设备单元的默认样式，“AE Pipeline”是管线的默认样式。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAE样式将使用“思源黑体”作为指定字体，在AE PID插件的安装过程中会自动为系统安装思源黑体。若未能正确显示思源黑体，请尝试手动安装。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"styles.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aefdebed9f.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e若要修改图框大小，用鼠标右键点击图框，并在子类中选择合适的尺寸;\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"context-menu-frame.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af01620a3f.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在选项卡中点击“编辑”-“库”加载模具库。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"libraries.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af04a85a0b.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e从“AE逻辑”库中拖拽“功能单元”至绘图区；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"drage-functional-group.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aedd3d0fad.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当您不确定所需的设备对象属于哪一个类型时，可以借助Visio模具的搜索栏进行搜索。这将帮助您快速找到所需的设备对象，无需事先知道其具体类型。\u003c/p\u003e\n\u003cp\u003e如果您正在使用Windows11系统，搜索功能可能未能如期使用，请按照\u003ca href=\"https://support.microsoft.com/zh-cn/office/%E4%BD%BF%E7%94%A8-%E5%BD%A2%E7%8A%B6-%E7%AA%97%E5%8F%A3%E7%BB%84%E7%BB%87%E5%92%8C%E6%9F%A5%E6%89%BE%E5%BD%A2%E7%8A%B6-2e468457-1059-49d3-8955-32b2527cce98\"\u003e修复了Visio桌面应用中的形状Windows 11\u003c/a\u003e的方法修补。\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e用鼠标右键点击该“功能单元”，打开“形状数据”面板;\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"open-shape-data.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aedaa2f34a.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在“形状数据”面板中输入“功能组”值：“GF612”，“功能组名称”值：“中途洁净间循环风机”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"funtioanl-group-shape-data.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aed82bc473.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此时，功能单元显示如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"functioanl-group.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aed70be374.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用相同的方法从“AE基础”库中拖拽“鼓风机”至功能组内，此时可以看到功能单元边框被高亮为绿色，表示该风机已被加入功能单元。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"fan-in-the-functional-group.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aed5575474.png\"\u003e\u003c/p\u003e\n\u003cp\u003e保持风机的选中状态，在“形状数据”面板中键入“功能元件”值：11，按下回车后该值将显示为“GQ11”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"fan-shape-data.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0ba8eda5.png\"\u003e\u003c/p\u003e\n\u003cp\u003e拖动GQ11上的黄色控制点，可以移动功能元件标签的位置；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"control-of-functioanl-element.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0e72c227.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e为了表示鼓风机配备的电机，从“AE逻辑”库中拖拽“代理功能元件”至功能组内；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"functional-element.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0cdba438.png\"\u003e\u003c/p\u003e\n\u003cp\u003e选中该代理功能元件，将黄色控制点拖拽至鼓风机上，使代理功能元件与鼓风机相关联；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"assing-functional-element-to-fun.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aece81e029.png\"\u003e\u003c/p\u003e\n\u003cp\u003e被关联后，代理功能元件的形状数据处可以看见被关联设备的位号；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"parent-designation.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aed1c766b3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e当被关联设备发生移动时，关联元件会跟随移动；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"move-along-with-parent.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aecff16d92.png\"\u003e\u003c/p\u003e\n\u003cp\u003e保持代理功能元件的选中状态，补充“元件位号”值：“MA01”，描述：“电机”，并将代理功能元件拖拽至鼓风机附近。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"move-functional-element-near-fun.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0fbe55b6.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e继续从“AE基础”库中拖拽“仪表”至功能单元中，并在右键菜单中选择“子类”-“本地面板监视仪表”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"selection-of-subclass-for-instrument.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac8eb44fb1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e补充形状数据并将仪表移动至合适的位置；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"move-and-supplyment.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac8d0e5c8f.png\"\u003e\u003c/p\u003e\n\u003cp\u003e将仪表正中的控制点拖拽至鼓风机上；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"move-line.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac8bf75596.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用同样的方法绘制下方的“中控监视操作仪表”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"another-instrument.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac8b0e1255.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e从“AE管线”库中拖拽“管路”至绘图区，并在“子类”中选择“排出空气”使其显示为柠黄色；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"pipe.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac89c3a9d1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e将管路一段连在鼓风机的连接点上，另一端连接至其他对象，并在右键菜单中点击“改变箭头方向”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"change-arrow-direction.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac86daeba9.png\"\u003e\u003c/p\u003e\n\u003cp\u003e多次点击直到箭头朝向如图所示；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"arrow-direction.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac88606f6a.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用相同的方法完成另一根管路的绘制；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"other-pipe.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af10d54d44.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在选项卡中点击“导出”-“BOM”查看当前图纸的BOM结构；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"bom-structure.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac75d97286.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在选项卡中点击“编辑”-“图例”将在图签上方生成图例；\u003c/p\u003e","title":"AE PID快速入门"},{"content":"分享一些Visio模具库建库过程中值得注意的事项以及原因。\n模具的BaseID的唯一性。\nBaseID是Master对象的属性之一，Master对象有三个ID：BaseID，UniqueID和ID。BaseID在Master被创建时生成，且不再改变（除非使用程序修改）。因此BaseID非常适合作为维护Master对象时的唯一标识。这是因为，UniqueID会随着Master内容的修改而变化，ID会随着不同的文档而变化。\n通常情况下，我们不需要关注BaseID，因为当我们将形状从绘图页拖拽至模具库时，会创建唯一的BaseID。但是，很多管理员在建立新模具时，为了省去添加通用形状和属性，如Tag文本，备注属性等，会直接在模具库中选中已经存在的模具复制粘贴，然后在粘贴后的模具中进行修改。这个时候站贴后的模具将和源模具具有相同的BaseID。为了保证BaseID的唯一性，可以在程序中调用Master.NewBaseID方法获取新的BaseID，或者直接在Openxml文档中键入新的BaseID。\n模具的形状界限与网格线重合。\n由于Visio中的默认吸附设置包括网格线，当模具的形状界限是网格的整数倍时，模具实例的边界可以吸附在网格线上，这样用者不需要再使用对齐工具也可以快速的实现多个形状的对齐，从而使页面看起来更整洁。\n这就要求管理员在设计模具的形状时，充分考虑形状的轮廓尺寸。当然，有些情况下没有办法保证这些线条刚好经过网格线，但是仍然可以通过手动设置形状的Width和Height，使其包围框刚好位于网格线上。\n例如，对于图中的两个阀门，尽管电磁气动阀的轮廓远比通用阀门大，但是他们都使用同样的形状界限，即5mmx5mm。（这样做另一个隐藏的好处是：当用户使用电磁气动阀替换通用阀门时，不需要再调整对象的位置，因为他们是同轴的。）\n在ShapeSheet的Geometry中使用GUARD和Rel而不是使用绝对尺寸。\n当我们在ShapeSheet中修改Geometry属性时，很容易遇到插入一个新的数据行引发形状的Width和Height重新计算，导致才修改好的形状意外改变。因此，在设计初期就应该使用GUARD对形状的Width和Height以及几何数据写保护，防止插入新的几何数据时Visio重新计算引发的意外情况。\n在几何数据中使用相对值而不是绝对值，则是为了解决用户手动调整实例尺寸时，代表实例的几何形状可以保持正确的比例，以防出现原来是个原型，现在是个椭圆形的情况。\n在创建具有多个子类的对象时，将表示不通子类的多个几何数据创建在同一个形状对象上，而不是使用多个形状对象。\n这句话描述的可能比较抽象。有的时候，为了缩减模具库中模具的数量，管理员可能会考虑将多个具有类似的对象设计成一个模具，并通过属性切换显示与隐藏。例如，图中的阀门聚合了多种形式的阀体，并根据用户的选择进行形状的切换。\n在实现这个功能时，有两种做法：方法一是在模具的形状组中创建多个形状用以表示不通的阀体，例如三个形状分别表示通用发、三通阀、角式阀；方法二是在一个形状中，插入多个几何数据块。我认为方法二是更好的做法，因为如果用户在使用过程中解散了图纸中实例的组，不会在图纸中生成隐藏的形状对象。尽管这样增加了管理的复杂性，因为无法通过形状的名称判断几何数据块表示的形状。\n","permalink":"http://localhost:1313/posts/visio%E6%A8%A1%E5%85%B7%E5%BA%93%E5%BB%BA%E5%BA%93%E6%8C%87%E5%AF%BC/","summary":"\u003cp\u003e分享一些Visio模具库建库过程中值得注意的事项以及原因。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e模具的BaseID的唯一性。\u003c/p\u003e\n\u003cp\u003eBaseID是Master对象的属性之一，Master对象有三个ID：BaseID，UniqueID和ID。BaseID在Master被创建时生成，且不再改变（除非使用程序修改）。因此BaseID非常适合作为维护Master对象时的唯一标识。这是因为，UniqueID会随着Master内容的修改而变化，ID会随着不同的文档而变化。\u003c/p\u003e\n\u003cp\u003e通常情况下，我们不需要关注BaseID，因为当我们将形状从绘图页拖拽至模具库时，会创建唯一的BaseID。但是，很多管理员在建立新模具时，为了省去添加通用形状和属性，如Tag文本，备注属性等，会直接在模具库中选中已经存在的模具复制粘贴，然后在粘贴后的模具中进行修改。这个时候站贴后的模具将和源模具具有相同的BaseID。为了保证BaseID的唯一性，可以在程序中调用\u003ccode\u003eMaster.NewBaseID\u003c/code\u003e方法获取新的BaseID，或者直接在Openxml文档中键入新的BaseID。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"two-masters-with-the-same-baseid.png\" loading=\"lazy\" src=\"https://s2.loli.net/2024/01/29/jmtXBGreoUuLv13.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e模具的形状界限与网格线重合。\u003c/p\u003e\n\u003cp\u003e由于Visio中的默认吸附设置包括网格线，当模具的形状界限是网格的整数倍时，模具实例的边界可以吸附在网格线上，这样用者不需要再使用对齐工具也可以快速的实现多个形状的对齐，从而使页面看起来更整洁。\u003c/p\u003e\n\u003cp\u003e这就要求管理员在设计模具的形状时，充分考虑形状的轮廓尺寸。当然，有些情况下没有办法保证这些线条刚好经过网格线，但是仍然可以通过手动设置形状的Width和Height，使其包围框刚好位于网格线上。\u003c/p\u003e\n\u003cp\u003e例如，对于图中的两个阀门，尽管电磁气动阀的轮廓远比通用阀门大，但是他们都使用同样的形状界限，即5mmx5mm。（这样做另一个隐藏的好处是：当用户使用电磁气动阀替换通用阀门时，不需要再调整对象的位置，因为他们是同轴的。）\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"two-valves-with-the-same-bounding-box.png\" loading=\"lazy\" src=\"https://s2.loli.net/2024/01/29/Z37GH1u9pV6Lt5z.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在ShapeSheet的Geometry中使用GUARD和Rel而不是使用绝对尺寸。\u003c/p\u003e\n\u003cp\u003e当我们在ShapeSheet中修改Geometry属性时，很容易遇到插入一个新的数据行引发形状的Width和Height重新计算，导致才修改好的形状意外改变。因此，在设计初期就应该使用GUARD对形状的Width和Height以及几何数据写保护，防止插入新的几何数据时Visio重新计算引发的意外情况。\u003c/p\u003e\n\u003cp\u003e在几何数据中使用相对值而不是绝对值，则是为了解决用户手动调整实例尺寸时，代表实例的几何形状可以保持正确的比例，以防出现原来是个原型，现在是个椭圆形的情况。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在创建具有多个子类的对象时，将表示不通子类的多个几何数据创建在同一个形状对象上，而不是使用多个形状对象。\u003c/p\u003e\n\u003cp\u003e这句话描述的可能比较抽象。有的时候，为了缩减模具库中模具的数量，管理员可能会考虑将多个具有类似的对象设计成一个模具，并通过属性切换显示与隐藏。例如，图中的阀门聚合了多种形式的阀体，并根据用户的选择进行形状的切换。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"compounded-valves.png\" loading=\"lazy\" src=\"https://s2.loli.net/2024/01/29/Pg2QBtfUwYVy1Ae.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在实现这个功能时，有两种做法：方法一是在模具的形状组中创建多个形状用以表示不通的阀体，例如三个形状分别表示通用发、三通阀、角式阀；方法二是在一个形状中，插入多个几何数据块。我认为方法二是更好的做法，因为如果用户在使用过程中解散了图纸中实例的组，不会在图纸中生成隐藏的形状对象。尽管这样增加了管理的复杂性，因为无法通过形状的名称判断几何数据块表示的形状。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"Visio模具库建库指导"},{"content":"属性类型 在ReactiveUI中，ViewModel中的属性可以根据其用途划分为三种情况：读写属性（Read-Write Properties）、只读属性（Read-Only Properties）和输出属性（Output Properties）。\n读写属性 (Read-Write Properties):\n读写属性是可以被服务修改，也可以被用户在View中修改的属性。这类属性是我们通常比较熟悉的普通属性。\n例如，用户的姓名可能是被服务加载的，而在加载之后又被用户修改。\n只读属性 (Read-Only Properties):\n只读属性是在构造函数中被初始化且在之后不再变化的属性。\n例如， 用户的ID在一般情况下时不允许变化的。\n输出属性 (Output Properties):\n输出属性是ReactiveUI中新提出的概念，初次接触ReactiveUI时，可能会将输出属性与只读属性混为一谈。尽管输出属性对于用户而言是只读的，但是对于属性本身是可变的。这类属性通常由Observable变化而成，表示属性值可能随时间变化。 例如，用户负债率随用户的总资产和总负债变化，但负债率属性本身是不允许被用户修改的。\n在ReactiveUI中，使用这三种属性类型可以更清晰地表示属性的特性和用途。读写属性用于需要双向绑定的数据，只读属性用于一次性初始化后不再改变的数据，而输出属性用于表示可能随时间变化的数据流。这种划分有助于更好地理解和管理ViewModel中的属性。\n属性的声明与绑定方法 在明确了属性类型的基础上，ViewModel中所有非集合类型的属性都可以按照下面固定的方式进行声明与绑定。\n读写属性的声明需要调用ReactiveObject的RaiseAndSetIfChanged方法，该方法实现了INotifydPropertyChanged。\nprivate string name; public string Name { get =\u0026gt; name; set =\u0026gt; this.RaiseAndSetIfChanged(ref name, value); } 读写属性的绑定使用TView的Bind方法进行双向绑定。\nthis.WhenActivated(disposable =\u0026gt; { this.Bind(ViewModel, vm =\u0026gt; vm.Name, v =\u0026gt; v.NameTextBox.Text) .DisposeWith(disposable); }); 只读属性使用一般的声明方式即可。\npublic int Id {get;} 绑定时，使用单向绑定。\nthis.WhenActivated(disposable =\u0026gt; { this.OneWayBind(ViewModel, vm =\u0026gt; vm.Id, v =\u0026gt; v.IdTextBlock.Text) .DisposeWith(disposable); }); 输出属性也是使用固定的方式进行声明，但是在初始化时需要注意。\n// 声明 private readonly ObservableAsPropertyHelper\u0026lt;double\u0026gt; _debtAssetRatio; public string DebtAssetRatio =\u0026gt; _debtAssetRatio.Value; // WhenAnyValue产生一个Observable，当Debt或Asset变化时，会发出新的Debt/Asset的值。这里需要注意Debt和Asset必须也实现了INotifyPropertyChanged，否则无法观察到它们的变化。 // ToProperty将Observable转变为ObservableAsPropertyHelper。 UserAccountViewModel(){ this.WhenAnyValue(x =\u0026gt; x.Debt, x =\u0026gt; x.Asset, (debt, asset) =\u0026gt; debt/asset) .ToProperty(this, x =\u0026gt; x.DebtAssetRatio, out _debtAssetRatio); } 由于输出属性对用户而言也是只读的，所以使用单向绑定。\nthis.WhenActivated(disposable =\u0026gt; { this.OneWayBind(ViewModel, vm =\u0026gt; vm.DebtAssetRatio, v =\u0026gt; v.DebtAssetRatioTextBlock.Text) .DisposeWith(disposable); }); 集合 在使用集合类型的数据，最简单的情况是View中使用的是不可变的数据集合，例如显示Blog中已归档的文章列表，显示用户银行账户的历史交易信息等。这种情况下由于数据只在构造函数中被初始化，所以可以声明为任意集合类型，例如IEnmerable\u0026lt;T\u0026gt;、 IList\u0026lt;T\u0026gt;、ObservableCollection\u0026lt;T\u0026gt;。再在View中使用OneWayBind绑定。\n// ViewModel public IEnumerable\u0026lt;Article\u0026gt; Articles {get;} // View this.WhenActivated(disposable =\u0026gt; { this.OneWayBind(ViewModel, vm =\u0026gt; vm.Articles, v =\u0026gt; v.DataGrid.ItemsSource) .DisposeWith(disposable); }); 对于可变数据集合，则需要将集合声明为ObservableCollection\u0026lt;T\u0026gt;，然后在View中使用OneWayBind绑定。要注意的是T也需要实现INotifydPropertyChanged，否则T属性的变化无法触发View更新。\n到目前为止这和我们在以往使用WPF进行数据绑定时没有任何差异，那为什么还要将集合单拎出来特别说明。这是因为在ReactiveUI中推荐使用Dynamic Data来操作集合。ReactiveUI的文档中写的比较抽象，这里我将举例说明为什么使用Dynamic Data可以帮助我们更好的维护代码。\n在这个例子中，我将使用到两个DataGrid，其中SourceDataGrid中显示带有复选框的用户数据，SourceDataGrid中被选中的数据将被显示在OutputDataGrid中，也就是说OutputDataGrid是SourceDataGrid的一个视图。View的代码如下：\n// in MainWindow.xaml.xaml \u0026lt;Grid\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid Margin=\u0026#34;0 0 4 0\u0026#34;\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Original DataGrid with Read-Write Items\u0026#34; /\u0026gt; \u0026lt;DataGrid Grid.Row=\u0026#34;1\u0026#34; x:Name=\u0026#34;SourceDataGrid\u0026#34; AutoGenerateColumns=\u0026#34;False\u0026#34;\u0026gt; \u0026lt;DataGrid.Columns\u0026gt; \u0026lt;DataGridCheckBoxColumn Binding=\u0026#34;{Binding IsSelected, UpdateSourceTrigger=PropertyChanged}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Id}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Name}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Age}\u0026#34; /\u0026gt; \u0026lt;/DataGrid.Columns\u0026gt; \u0026lt;/DataGrid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;Grid Grid.Column=\u0026#34;1\u0026#34; Margin=\u0026#34;4 0 0 0\u0026#34;\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;TextBlock Text=\u0026#34;DataGrid Shows Output Properties that Filters IsSelected\u0026#34; /\u0026gt; \u0026lt;DataGrid Grid.Row=\u0026#34;1\u0026#34; x:Name=\u0026#34;OutputDataGrid\u0026#34; AutoGenerateColumns=\u0026#34;False\u0026#34;\u0026gt; \u0026lt;DataGrid.Columns\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Id}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Name}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Age}\u0026#34; /\u0026gt; \u0026lt;/DataGrid.Columns\u0026gt; \u0026lt;/DataGrid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; //in MainWindow.xaml.cs this.WhenActivated(disposable =\u0026gt; { this.OneWayBind(ViewModel, vm =\u0026gt; vm.ReadWriteItems, v =\u0026gt; v.SourceDataGrid.ItemsSource) .DisposeWith(disposable); this.OneWayBind(ViewModel, vm =\u0026gt; vm.OutputItems, v =\u0026gt; v.OutputDataGrid.ItemsSource) .DisposeWith(disposable); }); 在不使用Dynamic Data时，要使OutputItems在ReadWriteItems发生变化时同步刷新，可以选在在ReadWriteItems属性变化时，调用ReactiveObject的RaisePropertyChanged方法。但是，因为ObservableCollection只提供了CollectionChanged事件，这个事件只有当集合增删时会被触发，所以必须遍历ReadWriteItems的对象并在Item对象的PropertyChanged事件上增加处理方法。\npublic ObservableCollection\u0026lt;ItemViewModel\u0026gt; ReadWriteItems { get; } public IEnumerable\u0026lt;ItemViewModel\u0026gt; OutputItems =\u0026gt; ReadWriteItems.Where(x =\u0026gt; x.IsSelected); public MainWindowViewModel{ ReadWriteItems = new ObservableCollection\u0026lt;ItemViewModel\u0026gt;(ItemViewModel.GetItems()); foreach (var item in ReadWriteItems) item.PropertyChanged += (sender, args) =\u0026gt; { this.RaisePropertyChanged(nameof(OutputItems)); }; } 这种做法将业务逻辑分散在两个地方，表示筛选的部分放在了属性的声明中，而表示刷新的部分放在了构造函数中。当代码体量增加时，分散的代码会增加运维的成本。而使用Dynamic Data，可以将上述分散的代码合并在构造函数中。\nprivate readonly ReadOnlyObservableCollection\u0026lt;ItemViewModel\u0026gt; _outputItems; public ObservableCollection\u0026lt;ItemViewModel\u0026gt; ReadWriteItems { get; } public ReadOnlyObservableCollection\u0026lt;ItemViewModel\u0026gt; OutputItems =\u0026gt; _outputItems; public MainWindowViewModel{ ReadWriteItems = new ObservableCollection\u0026lt;ItemViewModel\u0026gt;(ItemViewModel.GetItems()); var disposable = ReadWriteItems.ToObservableChangeSet() .AutoRefresh() // .AutoRefreshOnObservable(x=\u0026gt;x.WhenPropertyChanged(i=\u0026gt;i.IsSelected)) .Filter(x=\u0026gt;x.IsSelected) .Bind(out _outputItems) .Subscribe(); } 在这段代码中，我们首先将ReadWriteItems转化为IObservable\u0026lt;IChangeSet\u0026lt;ItemViewModel\u0026gt;\u0026gt;，然后使用AutoRefresh将ReadWriteItems的变化向下传递，最终绑定到_outputItems中。在过程中我们调用Filter操作符对数据进行筛选，选出被选中的对象，还可以在后面串联更多的操作符对数据进行变换。需要注意结尾的Subscribe调用是不可缺少的，因为只有在被订阅后，上述操作才会生效。\n同样的原理，有时我们需要根据集合中数据的状态来切换按钮的状态，例如只有当全被选中时，才允许按钮被点击。\nprivate readonly ObservableAsPropertyHelper\u0026lt;bool\u0026gt; _isEnabled; public ObservableCollection\u0026lt;ItemViewModel\u0026gt; ReadWriteItems { get; } public bool IsEnabled =\u0026gt; _isEnabled.Value; public MainWindowViewModel{ ReadWriteItems = new ObservableCollection\u0026lt;ItemViewModel\u0026gt;(ItemViewModel.GetItems()); _isEnabled = ReadWriteItems.ToObservableChangeSet() .AutoRefresh() .ToCollection() .Select(x =\u0026gt; x.All(i =\u0026gt; i.IsSelected)) .ToProperty(this, x =\u0026gt; x.IsEnabled); } ","permalink":"http://localhost:1313/posts/reactiveui-viewmodel-properties%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"属性类型\"\u003e属性类型\u003c/h2\u003e\n\u003cp\u003e在ReactiveUI中，ViewModel中的属性可以根据其用途划分为三种情况：读写属性（Read-Write Properties）、只读属性（Read-Only Properties）和输出属性（Output Properties）。\u003c/p\u003e\n\u003cp\u003e读写属性 (Read-Write Properties):\u003c/p\u003e\n\u003cp\u003e读写属性是可以被服务修改，也可以被用户在View中修改的属性。这类属性是我们通常比较熟悉的普通属性。\u003c/p\u003e\n\u003cp\u003e例如，用户的姓名可能是被服务加载的，而在加载之后又被用户修改。\u003c/p\u003e\n\u003cp\u003e只读属性 (Read-Only Properties):\u003c/p\u003e\n\u003cp\u003e只读属性是在构造函数中被初始化且在之后不再变化的属性。\u003c/p\u003e\n\u003cp\u003e例如， 用户的ID在一般情况下时不允许变化的。\u003c/p\u003e\n\u003cp\u003e输出属性 (Output Properties):\u003c/p\u003e\n\u003cp\u003e输出属性是ReactiveUI中新提出的概念，初次接触ReactiveUI时，可能会将输出属性与只读属性混为一谈。尽管输出属性对于用户而言是只读的，但是对于属性本身是可变的。这类属性通常由Observable变化而成，表示属性值可能随时间变化。\n例如，用户负债率随用户的总资产和总负债变化，但负债率属性本身是不允许被用户修改的。\u003c/p\u003e\n\u003cp\u003e在ReactiveUI中，使用这三种属性类型可以更清晰地表示属性的特性和用途。读写属性用于需要双向绑定的数据，只读属性用于一次性初始化后不再改变的数据，而输出属性用于表示可能随时间变化的数据流。这种划分有助于更好地理解和管理ViewModel中的属性。\u003c/p\u003e\n\u003ch2 id=\"属性的声明与绑定方法\"\u003e属性的声明与绑定方法\u003c/h2\u003e\n\u003cp\u003e在明确了属性类型的基础上，ViewModel中所有\u003ccode\u003e非集合类型\u003c/code\u003e的属性都可以按照下面固定的方式进行声明与绑定。\u003c/p\u003e\n\u003cp\u003e读写属性的声明需要调用ReactiveObject的RaiseAndSetIfChanged方法，该方法实现了INotifydPropertyChanged。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eName\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eget\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRaiseAndSetIfChanged\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eref\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e读写属性的绑定使用TView的Bind方法进行双向绑定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenActivated\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eBind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eName\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eNameTextBox\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eText\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDisposeWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e只读属性使用一般的声明方式即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eId\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"k\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e绑定时，使用单向绑定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenActivated\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOneWayBind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eId\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eIdTextBlock\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eText\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDisposeWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e输出属性也是使用固定的方式进行声明，但是在初始化时需要注意。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 声明\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003ereadonly\u003c/span\u003e \u003cspan class=\"n\"\u003eObservableAsPropertyHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_debtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eDebtAssetRatio\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_debtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// WhenAnyValue产生一个Observable，当Debt或Asset变化时，会发出新的Debt/Asset的值。这里需要注意Debt和Asset必须也实现了INotifyPropertyChanged，否则无法观察到它们的变化。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// ToProperty将Observable转变为ObservableAsPropertyHelper。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eUserAccountViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenAnyValue\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDebt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAsset\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edebt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003easset\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003edebt\u003c/span\u003e\u003cspan class=\"p\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003easset\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eToProperty\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDebtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003eout\u003c/span\u003e \u003cspan class=\"n\"\u003e_debtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e由于输出属性对用户而言也是只读的，所以使用单向绑定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenActivated\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOneWayBind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDebtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDebtAssetRatioTextBlock\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eText\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDisposeWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"集合\"\u003e集合\u003c/h2\u003e\n\u003cp\u003e在使用集合类型的数据，最简单的情况是View中使用的是不可变的数据集合，例如显示Blog中已归档的文章列表，显示用户银行账户的历史交易信息等。这种情况下由于数据只在构造函数中被初始化，所以可以声明为任意集合类型，例如\u003ccode\u003eIEnmerable\u0026lt;T\u0026gt;\u003c/code\u003e、 \u003ccode\u003eIList\u0026lt;T\u0026gt;\u003c/code\u003e、\u003ccode\u003eObservableCollection\u0026lt;T\u0026gt;\u003c/code\u003e。再在View中使用OneWayBind绑定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// ViewModel\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eIEnumerable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eArticle\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eArticles\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"k\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// View\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenActivated\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOneWayBind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eArticles\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDataGrid\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eItemsSource\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDisposeWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对于可变数据集合，则需要将集合声明为\u003ccode\u003eObservableCollection\u0026lt;T\u0026gt;\u003c/code\u003e，然后在View中使用OneWayBind绑定。要注意的是\u003ccode\u003eT\u003c/code\u003e也需要实现\u003ccode\u003eINotifydPropertyChanged\u003c/code\u003e，否则T属性的变化无法触发View更新。\u003c/p\u003e","title":"ReactiveUI ViewModel Properties总结"},{"content":"当使用Visual Studio Installer进行打包时，要实现安装时自动卸载旧版本然后安装新版本，需要同时设置以下各点：\nDeployment Project Properties -\u0026gt; DetectNewerInstalledVersion -\u0026gt; True Deployment Project Properties -\u0026gt; RemovePreviousVersions -\u0026gt; True Deployment Project Properties -\u0026gt; Version 其中，Version被安装程序用来判断是否继续执行安装程序，所以Version值应大于上一个版本。\n满足以上条件时，执行安装程序可以顺利执行，且控制面板中可以看到更新后的版本号。但是，安装程序仍然可能没有正确执行。这是因为项目的主输出并没有被正确拷贝。这往往是因为没有正确设置项目（程序项目，非部署项目）的AssemblyInfo。主输出中的Version将被用来比较是否需要拷贝主输出到安装目录，所以当上一版本的主输出版本为0.2.1.0时，即使已经设置部署项目的Version为0.2.2.0，由于此时主输出的版本仍然为0.2.1.0，安装过程中不会拷贝新生成的主输出到安装目录。\n主输出的Version设置位于程序项目的AssemblyInfo.cs文件中。只有当此文件中的AssemblyVersion或AssemblyFileVersion的值大于上一个版本的值时，才会覆盖原安装目录的dll。\n","permalink":"http://localhost:1313/posts/visual-studio-installer%E5%AE%9E%E7%8E%B0%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B9%E6%B3%95/","summary":"\u003cp\u003e当使用Visual Studio Installer进行打包时，要实现安装时自动卸载旧版本然后安装新版本，需要同时设置以下各点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDeployment Project Properties -\u0026gt; DetectNewerInstalledVersion -\u0026gt; True\u003c/li\u003e\n\u003cli\u003eDeployment Project Properties -\u0026gt; RemovePreviousVersions -\u0026gt; True\u003c/li\u003e\n\u003cli\u003eDeployment Project Properties -\u0026gt; Version\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"deployment-project-properties.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/28/5ToctnJNzqDbaks.png\"\u003e\u003c/p\u003e\n\u003cp\u003e其中，Version被安装程序用来判断是否继续执行安装程序，所以Version值应大于上一个版本。\u003c/p\u003e\n\u003cp\u003e满足以上条件时，执行安装程序可以顺利执行，且控制面板中可以看到更新后的版本号。但是，安装程序仍然可能没有正确执行。这是因为项目的主输出并没有被正确拷贝。这往往是因为没有正确设置项目（程序项目，非部署项目）的AssemblyInfo。主输出中的Version将被用来比较是否需要拷贝主输出到安装目录，所以当上一版本的主输出版本为0.2.1.0时，即使已经设置部署项目的Version为0.2.2.0，由于此时主输出的版本仍然为0.2.1.0，安装过程中不会拷贝新生成的主输出到安装目录。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"assembly-info.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/28/BipWZAytP5qGQrl.png\"\u003e\u003c/p\u003e\n\u003cp\u003e主输出的Version设置位于程序项目的AssemblyInfo.cs文件中。只有当此文件中的AssemblyVersion或AssemblyFileVersion的值大于上一个版本的值时，才会覆盖原安装目录的dll。\u003c/p\u003e","title":"Visual Studio Installer实现覆盖安装新版本的方法"},{"content":"在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。\n尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。\n本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。\n拖拽背后的故事 当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。） 当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。\n这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。\n手动更新 要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。\n使用COM批量更新 借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。\n要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：\npublic IEnumerable\u0026lt;IVShape\u0026gt; GetInstances(IVMaster master) { var instances = document.Pages.OfType\u0026lt;IVPage\u0026gt;() .SelectMany(x =\u0026gt; x.Shapes.OfType\u0026lt;IVShape\u0026gt;()).Where(x =\u0026gt; x.Master == master).ToList(); return instances; } 要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。\n关键代码：\npublic IVMaster GetLatestMaster(IVDocument document, string baseID) { var latestMaster = document.Masters.OfType\u0026lt;IVMaster\u0026gt;() .SingleOrDefault(x =\u0026gt; x.BaseID == baseID); return latestMaster; } 然后，遍历这些事例，并将形状替换为新版本的模具。\npublic void Replace(IEnumerable\u0026lt;IVShape\u0026gt; instances, IVMaster latestMaster) { foreach (var instance in instances) { instance.ReplaceShape(latestMaster); } } 使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。\n另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。\n使用OpenXML批量更新 当不要求在原文件中完成更新时，可以考虑直接修改OpenXML文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为\u0026quot;.vsdx\u0026quot;。要查看OpenXML格式的详细内容，可以修改文档后缀为\u0026quot;.zip\u0026quot;后打开压缩包。\n.\\visio\\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。\n其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考以编程方式处理Visio文件格式):\npublic IEnumerable\u0026lt;XlElement\u0026gt; GetMasterElements(Package package) { // mastersPart指masters.xml var mastersPart = package.GetPart(XmlHelper.MastersPartUri); // 筛选出BaseID属性为baseID的Master节点 var masterElements = XmlHelper.GetXElementsByName(mastersPart, \u0026#34;Master\u0026#34;). return masterElements; } public PackagePart GetMasterContentsFile(Package package, string baseID){ var masterElement = GetMasterElement(package).SingleOrDefault(x=\u0026gt;x.Attribute(\u0026#34;BaseID\u0026#34;)!.Value == baseID); // 通过子节点Rel获取r:id var relElement = masterElement.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First(); var relId = relElement.Attribute(XmlHelper.RelNs + \u0026#34;id\u0026#34;)!.Value; var rel = mastersPart.GetRelationship(relId); // masterPart指master{i}.xml var masterPart = package.GetPart(PackUriHelper.ResolvePartUri(rel.SourceUri, rel.TargetUri)); return masterPart; } 当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：\npublic void Replace(Package drawingDoc, Package stencilDoc, string baseID){ var mastersPartDrawing = sourcePackage.GetPart(XmlHelper.MastersPartUri); foreach (var masterEleDrawing in GetMasterElements(drawingDoc)) { // 查看模具库中是否存在对应的Master var masterEleStencil = GetMasterElements(stencilDoc).SingleOrDefault(x=\u0026gt;x.Attribute(\u0026#34;BaseID\u0026#34;)!.Value == baseID); if (masterEleStencil == null) continue; // 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点 var relEleDrawing = masterEleDrawing.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First(); masterEleStencil.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First().ReplaceWith(relEleDrawing); masterEleDrawing.ReplaceWith(masterEleStencil); // 替换MasterContents var contentsPartDrawing = GetMasterContentsFile(drawingDoc, baseID); var contentsPartStencil = GetMasterContentsFile(stencilDoc, baseID); XmlHelper.SaveXDocumentToPart(contentsPartDrawing, XmlHelper.GetXmlFromPart(contentsPartStencil)); } XmlHelper.RecalculateDocument(drawingDoc); XmlHelper.SaveXDocumentToPart(mastersPartDrawing, XmlHelper.GetXmlFromPart(mastersPartDrawing)); } 查看完整代码\n","permalink":"http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0visio%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%85%B7/","summary":"\u003cp\u003e在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。\u003c/p\u003e\n\u003cp\u003e尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。\u003c/p\u003e\n\u003cp\u003e本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。\u003c/p\u003e\n\u003ch2 id=\"拖拽背后的故事\"\u003e拖拽背后的故事\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://techcommunity.microsoft.com/t5/microsoft-365-blog/drag-drop-done/ba-p/237244\"\u003e当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作\u003c/a\u003e。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。）\n当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。\u003c/p\u003e\n\u003cp\u003e这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。\u003c/p\u003e\n\u003ch2 id=\"手动更新\"\u003e手动更新\u003c/h2\u003e\n\u003cp\u003e要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"change-shape.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/26/YSPq96nDTp2vEib.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"使用com批量更新\"\u003e使用COM批量更新\u003c/h2\u003e\n\u003cp\u003e借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。\u003c/p\u003e\n\u003cp\u003e要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eIEnumerable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVShape\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eGetInstances\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eIVMaster\u003c/span\u003e \u003cspan class=\"n\"\u003emaster\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003einstances\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ePages\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOfType\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVPage\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSelectMany\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eShapes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOfType\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVShape\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;()).\u003c/span\u003e\u003cspan class=\"n\"\u003eWhere\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMaster\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003emaster\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eToList\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003einstances\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。\u003c/p\u003e\n\u003cp\u003e关键代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eIVMaster\u003c/span\u003e \u003cspan class=\"n\"\u003eGetLatestMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eIVDocument\u003c/span\u003e \u003cspan class=\"n\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003elatestMaster\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMasters\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOfType\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSingleOrDefault\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eBaseID\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003elatestMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后，遍历这些事例，并将形状替换为新版本的模具。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eReplace\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eIEnumerable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVShape\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003einstances\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eIVMaster\u003c/span\u003e \u003cspan class=\"n\"\u003elatestMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eforeach\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003einstance\u003c/span\u003e \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003einstances\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eReplaceShape\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elatestMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。\u003c/p\u003e\n\u003cp\u003e另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。\u003c/p\u003e\n\u003ch2 id=\"使用openxml批量更新\"\u003e使用OpenXML批量更新\u003c/h2\u003e\n\u003cp\u003e当不要求在原文件中完成更新时，可以考虑直接修改\u003ca href=\"https://learn.microsoft.com/en-us/office/client-developer/visio/introduction-to-the-visio-file-formatvsdx\"\u003eOpenXML\u003c/a\u003e文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为\u0026quot;.vsdx\u0026quot;。要查看OpenXML格式的详细内容，可以修改文档后缀为\u0026quot;.zip\u0026quot;后打开压缩包。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"open-vsdx-as-zip.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/26/1dKCDJwfYpV6B79.png\"\u003e\u003c/p\u003e\n\u003cp\u003e.\\visio\\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"master.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/26/BLtjEZDhK4a3crA.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"master-content.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/26/38Wx795LYotHfdk.png\"\u003e\u003c/p\u003e\n\u003cp\u003e其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考\u003ca href=\"https://learn.microsoft.com/en-us/office/client-developer/visio/how-to-manipulate-the-visio-file-format-programmatically\"\u003e以编程方式处理Visio文件格式\u003c/a\u003e):\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eIEnumerable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eXlElement\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterElements\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePackage\u003c/span\u003e \u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// mastersPart指masters.xml\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emastersPart\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMastersPartUri\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 筛选出BaseID属性为baseID的Master节点\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterElements\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetXElementsByName\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emastersPart\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Master\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003emasterElements\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003ePackagePart\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterContentsFile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePackage\u003c/span\u003e \u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterElement\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterElement\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eSingleOrDefault\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAttribute\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;BaseID\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)!.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 通过子节点Rel获取r:id\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003erelElement\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emasterElement\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDescendants\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMainNs\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Rel\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eFirst\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003erelId\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erelElement\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAttribute\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRelNs\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;id\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)!.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003erel\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emastersPart\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetRelationship\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erelId\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// masterPart指master{i}.xml\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterPart\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePackUriHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eResolvePartUri\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erel\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSourceUri\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003erel\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eTargetUri\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003emasterPart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eReplace\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePackage\u003c/span\u003e \u003cspan class=\"n\"\u003edrawingDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ePackage\u003c/span\u003e \u003cspan class=\"n\"\u003estencilDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emastersPartDrawing\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esourcePackage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMastersPartUri\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eforeach\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterEleDrawing\u003c/span\u003e \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterElements\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edrawingDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 查看模具库中是否存在对应的Master\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterEleStencil\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterElements\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estencilDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eSingleOrDefault\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAttribute\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;BaseID\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)!.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emasterEleStencil\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003erelEleDrawing\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emasterEleDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDescendants\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMainNs\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Rel\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eFirst\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003emasterEleStencil\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDescendants\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMainNs\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Rel\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eFirst\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eReplaceWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erelEleDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003emasterEleDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eReplaceWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emasterEleStencil\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 替换MasterContents\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003econtentsPartDrawing\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterContentsFile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edrawingDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003econtentsPartStencil\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterContentsFile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estencilDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSaveXDocumentToPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtentsPartDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetXmlFromPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtentsPartStencil\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRecalculateDocument\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edrawingDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSaveXDocumentToPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emastersPartDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetXmlFromPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emastersPartDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://github.com/Snailya/AE.PID/blob/main/PID.VisioAddIn/Controllers/Services/DocumentUpdater.cs\"\u003e查看完整代码\u003c/a\u003e\u003c/p\u003e","title":"如何更新Visio文档中的模具"},{"content":"很不幸，又遇到了同样的问题。但这次问题涉及到一个容器对象，该容器内的某个形状链接了容器的某个属性值。当使用Shape.Replace()方法进行更新时，该属性又被更新成“OBJ”。\n因此，按照之前提到的方法，我们首先删除了我们自定义的容器的基本属性，例如SelectMode、DisplayMode、CalWH等。然后重新执行更新程序。此时，“OBJ”被正确的属性值所取代。\n通过Visio应用程序的编辑模具功能，重新定义先前的基本属性，再次执行更新程序。不幸的是OBJ又出现了。\n最终我们发现，当同时满足以下两个条件时，会产生上述的BUG：\nIsTextEditTarget=False GlueType=8 ","permalink":"http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E4%BD%BF%E7%94%A8shape-replace%E6%96%B9%E6%B3%95%E6%98%BE%E7%A4%BAobj%E7%9A%84bug-2/","summary":"\u003cp\u003e很不幸，又遇到了同样的问题。但这次问题涉及到一个容器对象，该容器内的某个形状链接了容器的某个属性值。当使用Shape.Replace()方法进行更新时，该属性又被更新成“OBJ”。\u003c/p\u003e\n\u003cp\u003e因此，按照之前提到的方法，我们首先删除了我们自定义的容器的基本属性，例如SelectMode、DisplayMode、CalWH等。然后重新执行更新程序。此时，“OBJ”被正确的属性值所取代。\u003c/p\u003e\n\u003cp\u003e通过Visio应用程序的编辑模具功能，重新定义先前的基本属性，再次执行更新程序。不幸的是OBJ又出现了。\u003c/p\u003e\n\u003cp\u003e最终我们发现，当同时满足以下两个条件时，会产生上述的BUG：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIsTextEditTarget=False\u003c/li\u003e\n\u003cli\u003eGlueType=8\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/11/W17f94tyPncGdTC.png\"\u003e\n\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/13/dq1KO5MIRJYrBDs.png\"\u003e\u003c/p\u003e","title":"解决Visio使用Shape Replace方法显示OBJ的BUG 2"},{"content":"引言 许多Visio管理员在项目初期都会面临模具频繁更新的问题。由于Visio的机制，每当用户首次从模具库中拖拽模具至绘图页时，实际上是从该模具库中拷贝了模具的副本至文档模具中。这种机制无疑切断了文档模具与原模具库的联系，也造成管理更新模具库后无法将更新应用到已有的绘图上。当绘图上需要更新的形状数量较少时，可以使用Visio提供的更改形状功能手动更新。但是，当绘图页中存在大量的待更新形状时，使用使用程序进行批量更新。\n程序批量更新的方法是遍历文档模具，并通过文档模具中模具的BaseID从模具库中找到源模具，再比较两者的UniqueID是否一致。若UniqueID一致，说明该模具没有更新，应跳过操作；若不一致，说明源模具发生了更新。然后在绘图页中找到所有与该模具关联的形状，然后删除文档模具中的旧模具，再执行Shape.Replace()方法使用新的模具替换形状。\n这种方法通常是凑效的，但是在上一周中，我遇到了如下的BUG：更新后的形状显示Obj文本。仔细查看形状shapesheet，可以发现模具中已经定义好的TextField在形状中变成了空白，造成显示错误。\n不幸的是，未能在Google中搜到类似的问题反馈。\n问题排查 通过查看xml文件，发现该形状的Field节被替换为了\u0026lt;Row IX='0' Del='1'/\u0026gt;。对比未出现显示错误的形状的xml文件可以发现：当TextField取值为空时，Field节应该继承自模具，因此xml文档不应出现Field节；当TextField存在取值时，Row节点内应该有Cell节点。此时，如果手动删除Field节，显示的OBJ文字消失。由此可以推出Field节数据发生了异常。\n但是，仍然无法确定该异常的产生是因为形状定义错误还是其他。\n回到Visio应用程序中，在源模具中的形状树中删除发生该问题的子形状，再次执行更新程序，原本没有问题的子形状的TextField出现同样的问题。重复执行删除子形状并更新的操作，问题始终出现。当所有的子形状都被删除后，更新后的形状不再显示OBJ。但是，新的问题出现了：形状显示数字3。显然我们并没有在模具的任何形状或子形状中定义过这个数值。\n由此可以推出，形状定义并没有问题，而是其他数据导致了Visio更新时的异常行为。\n为了确定是哪一部分数据存在问题，我们清空了User、ShapeData等全部用于定义用户数据的Section，问题依然复现。现在，只剩模具的基础数据了（诸如PinX、PinY等Shape节点下的Cell节点）。由于Visio中不能删除基础数据，所以在XML文件中用其他正常模具的基础数据替换问题模具的基础数据。此后，再使用程序对绘图页的形状进行更新，数字3不再出现，也就是这个BUG被修复了。\n通过文本对比工具，我们比较了问题模具与正常模具的基础数据。\n（此处，因为重启电脑图丢了。。。。。）\n比较两者的基础数据并没有特别的地方，除了尺寸和定位存在数值差异外，只有Cell的顺序存在区别。最终也无法确定这个问题到底是怎么产生的。\n解决方法 尽管未能找到该问题形成的原因，但通过定位问题位置，我们找到了解决该问题的方法：即使用正常模具的基础数据覆盖问题模具。\n","permalink":"http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E4%BD%BF%E7%94%A8shape-replace%E6%96%B9%E6%B3%95%E6%98%BE%E7%A4%BAobj%E7%9A%84bug/","summary":"\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cp\u003e许多Visio管理员在项目初期都会面临模具频繁更新的问题。由于Visio的机制，每当用户首次从模具库中拖拽模具至绘图页时，实际上是从该模具库中拷贝了模具的副本至文档模具中。这种机制无疑切断了文档模具与原模具库的联系，也造成管理更新模具库后无法将更新应用到已有的绘图上。当绘图上需要更新的形状数量较少时，可以使用Visio提供的更改形状功能手动更新。但是，当绘图页中存在大量的待更新形状时，使用使用程序进行批量更新。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/09/26/oXsOTbSZ73U4wyV.png\"\u003e\u003c/p\u003e\n\u003cp\u003e程序批量更新的方法是遍历文档模具，并通过文档模具中模具的BaseID从模具库中找到源模具，再比较两者的UniqueID是否一致。若UniqueID一致，说明该模具没有更新，应跳过操作；若不一致，说明源模具发生了更新。然后在绘图页中找到所有与该模具关联的形状，然后删除文档模具中的旧模具，再执行Shape.Replace()方法使用新的模具替换形状。\u003c/p\u003e\n\u003cp\u003e这种方法通常是凑效的，但是在上一周中，我遇到了如下的BUG：更新后的形状显示Obj文本。仔细查看形状shapesheet，可以发现模具中已经定义好的TextField在形状中变成了空白，造成显示错误。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"企业微信截图_16947712887795.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/09/26/IDtNBP16GOdfxu4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e不幸的是，未能在Google中搜到类似的问题反馈。\u003c/p\u003e\n\u003ch2 id=\"问题排查\"\u003e问题排查\u003c/h2\u003e\n\u003cp\u003e通过查看xml文件，发现该形状的Field节被替换为了\u003ccode\u003e\u0026lt;Row IX='0' Del='1'/\u0026gt;\u003c/code\u003e。对比未出现显示错误的形状的xml文件可以发现：当TextField取值为空时，Field节应该继承自模具，因此xml文档不应出现Field节；当TextField存在取值时，Row节点内应该有Cell节点。此时，如果手动删除Field节，显示的OBJ文字消失。由此可以推出Field节数据发生了异常。\u003c/p\u003e\n\u003cp\u003e但是，仍然无法确定该异常的产生是因为形状定义错误还是其他。\u003c/p\u003e\n\u003cp\u003e回到Visio应用程序中，在源模具中的形状树中删除发生该问题的子形状，再次执行更新程序，原本没有问题的子形状的TextField出现同样的问题。重复执行删除子形状并更新的操作，问题始终出现。当所有的子形状都被删除后，更新后的形状不再显示OBJ。但是，新的问题出现了：形状显示数字3。显然我们并没有在模具的任何形状或子形状中定义过这个数值。\u003c/p\u003e\n\u003cp\u003e由此可以推出，形状定义并没有问题，而是其他数据导致了Visio更新时的异常行为。\u003c/p\u003e\n\u003cp\u003e为了确定是哪一部分数据存在问题，我们清空了User、ShapeData等全部用于定义用户数据的Section，问题依然复现。现在，只剩模具的基础数据了（诸如PinX、PinY等Shape节点下的Cell节点）。由于Visio中不能删除基础数据，所以在XML文件中用其他正常模具的基础数据替换问题模具的基础数据。此后，再使用程序对绘图页的形状进行更新，数字3不再出现，也就是这个BUG被修复了。\u003c/p\u003e\n\u003cp\u003e通过文本对比工具，我们比较了问题模具与正常模具的基础数据。\u003c/p\u003e\n\u003cp\u003e（此处，因为重启电脑图丢了。。。。。）\u003c/p\u003e\n\u003cp\u003e比较两者的基础数据并没有特别的地方，除了尺寸和定位存在数值差异外，只有Cell的顺序存在区别。最终也无法确定这个问题到底是怎么产生的。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e尽管未能找到该问题形成的原因，但通过定位问题位置，我们找到了解决该问题的方法：即使用正常模具的基础数据覆盖问题模具。\u003c/p\u003e","title":"解决Visio使用Shape Replace方法显示OBJ的BUG"},{"content":"引言 在 Visio 中，可以通过使用外部数据来创建和更新图标、图形和其它可视化元素。例如，可以通过外部数据绑定，建立形状与数据表之间的同步关系，实现当外部数据发生变化时，Visio 图形的自动更新。利用这个方法，既可以解决人工通过 Excel 批量修改形状数据的需求，又可以实现数据库自动更新数据的需求。\n但是，目前针对外部数据功能的教程非常少，均是以组织架构图或时序图为例，以人工拖拽的方式实现数据链接到形状，鲜有如何自动将导入的数据连接到形状的教程。尽管 Microsoft 官方提供了自动链接向导将导入的数据连接到形状的支持文档，但是仅参照该文档并不能实现我们如下的需求：\n通过数据导出功能导出形状的数据至 Excel 表格 通过数据导入及自动链接功能将修改后的 Excel 表格与 Visio 形状数据的自动绑定，实现形状数据的更新。 该需求应于我们的业务过程存在的批量修改某类设备型号、供应商的情况。面对大量的设备，如果通过 Visio 逐次去修改每个形状的数据，一是操作繁琐耗时，二是容易产生遗漏，以上两个问题均可以得到解决。\n问题描述 借助数据库导出向导，我们可以将指定图层上的形状数据导出至数据库（或 Excel 文档），导出过程中将使用形状的 ID 作为数据表的 Key。因此，在将数据表导回 Visio 时，只需将 Key 值与形状的 ID 关联，理论上应该可以实现自动将数据链接至形状。\n但是，在实际操作中，外部数据窗口中并没有出现链接符号，即绑定失败了。\n此时，如果使用拖拽的方式将数据连接至形状，还会发现 Visio 并没有如期更新已有的属性，而是将表格中的属性作为新的属性写入形状。\n也就是说，要实现我们的需求需要解决如下两个问题：\n自动链接数据至形状数据 更新已有形状数据而不是新建数据 原因分析 针对问题一，使用录制宏功能，可以发现当设置形状的 ObjectID 与数据源中的 ShapeKey 匹配时，没有录制上任何有效代码，而其它选项均有代码被录制。因此推测 ID(Object Info)不是有效选项。\n针对问题二，由于在导出数据时，允许重新定义属性的名称，因此推测属性名称在更新数据时起关联作用，即表格中的列名称应与属性的 Name 或 Label 一致。经过多次尝试，应设置列名称为属性的 Label。\n解决方法 因此，要在 Visio 中实现外部数据绑定与自动更新，需要完成以下操作:\n在 User Section 中添加新的 ShapeID 属性，并设置其公式为\u0026quot;=GUARD(ID())\u0026quot;。 在数据导出窗口中，依次修改导出属性的 Field Name 为其 Label。 在自动链接窗口中，选择 Shape Field 的值为 User.ShapeID. 此时，修改后的数据已与形状自动关联。\n","permalink":"http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%A4%B1%E8%B4%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6id%E5%B1%9E%E6%80%A7/","summary":"\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cp\u003e在 Visio 中，可以通过使用外部数据来创建和更新图标、图形和其它可视化元素。例如，可以通过外部数据绑定，建立形状与数据表之间的同步关系，实现当外部数据发生变化时，Visio 图形的自动更新。利用这个方法，既可以解决人工通过 Excel 批量修改形状数据的需求，又可以实现数据库自动更新数据的需求。\u003c/p\u003e\n\u003cp\u003e但是，目前针对外部数据功能的教程非常少，均是以组织架构图或时序图为例，以人工拖拽的方式实现数据链接到形状，鲜有如何自动将导入的数据连接到形状的教程。尽管 Microsoft 官方提供了\u003ca href=\"https://support.microsoft.com/zh-cn/office/%E8%87%AA%E5%8A%A8%E5%B0%86%E5%AF%BC%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BD%A2%E7%8A%B6-be56f5ff-9b13-4311-9a6c-b27dd243dbea\"\u003e自动链接向导将导入的数据连接到形状\u003c/a\u003e的支持文档，但是仅参照该文档并不能实现我们如下的需求：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过数据导出功能导出形状的数据至 Excel 表格\u003c/li\u003e\n\u003cli\u003e通过数据导入及自动链接功能将修改后的 Excel 表格与 Visio 形状数据的自动绑定，实现形状数据的更新。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e该需求应于我们的业务过程存在的批量修改某类设备型号、供应商的情况。面对大量的设备，如果通过 Visio 逐次去修改每个形状的数据，一是操作繁琐耗时，二是容易产生遗漏，以上两个问题均可以得到解决。\u003c/p\u003e\n\u003ch2 id=\"问题描述\"\u003e问题描述\u003c/h2\u003e\n\u003cp\u003e借助数据库导出向导，我们可以将指定图层上的形状数据导出至数据库（或 Excel 文档），导出过程中将使用形状的 ID 作为数据表的 Key。因此，在将数据表导回 Visio 时，只需将 Key 值与形状的 ID 关联，理论上应该可以实现自动将数据链接至形状。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"key-field.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/KcMqIOdNn2SVwLi.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"link-to-object-id.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/FguYD1bfpV2OBlo.png\"\u003e\u003c/p\u003e\n\u003cp\u003e但是，在实际操作中，外部数据窗口中并没有出现链接符号，即绑定失败了。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"failed-on-linking-shape-id.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/lC1HozFsIpYK5rw.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此时，如果使用拖拽的方式将数据连接至形状，还会发现 Visio 并没有如期更新已有的属性，而是将表格中的属性作为新的属性写入形状。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"auto-create-properties.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/gz3oXulY4riAytB.png\"\u003e\u003c/p\u003e\n\u003cp\u003e也就是说，要实现我们的需求需要解决如下两个问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e自动链接数据至形状数据\u003c/li\u003e\n\u003cli\u003e更新已有形状数据而不是新建数据\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"原因分析\"\u003e原因分析\u003c/h2\u003e\n\u003cp\u003e针对问题一，使用录制宏功能，可以发现当设置形状的 ObjectID 与数据源中的 ShapeKey 匹配时，没有录制上任何有效代码，而其它选项均有代码被录制。因此推测 ID(Object Info)不是有效选项。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"vba-code.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/ZrU6nLWj3AzpqKI.png\"\u003e\u003c/p\u003e\n\u003cp\u003e针对问题二，由于在导出数据时，允许重新定义属性的名称，因此推测属性名称在更新数据时起关联作用，即表格中的列名称应与属性的 Name 或 Label 一致。经过多次尝试，应设置列名称为属性的 Label。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e因此，要在 Visio 中实现外部数据绑定与自动更新，需要完成以下操作:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 User Section 中添加新的 ShapeID 属性，并设置其公式为\u0026quot;\u003ccode\u003e=GUARD(ID())\u003c/code\u003e\u0026quot;。\n\u003cimg alt=\"shape-id.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/ytJuX4R3IxpNgrs.png\"\u003e\u003c/li\u003e\n\u003cli\u003e在数据导出窗口中，依次修改导出属性的 Field Name 为其 Label。\n\u003cimg alt=\"define-field-name.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/MRSHE8ay3e2jmoO.png\"\u003e\u003c/li\u003e\n\u003cli\u003e在自动链接窗口中，选择 Shape Field 的值为 User.ShapeID.\n\u003cimg alt=\"link-to-shape-id.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/RjM9OdT1m4nqphN.png\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e此时，修改后的数据已与形状自动关联。\u003c/p\u003e","title":"解决Visio外部数据绑定失败：自定义形状ID属性"},{"content":" 2025.3.17更新： 将文件另存为VSD格式，然后再另存为VSDX格式即可修复。\n引言 容器是 Visio 中一类可以帮助实现结构化组织和管理其它图形元素的特殊对象。通过容器，您可以将相关的子图形放置在一个框架内，以便更清晰地展示信息和关系。在管理员定义方面，与组合相比，容器可以实现更丰富的预定义内容：形状结构、外观样式、连接点定义等，以满足不同公司对图表样式的要求。在用户操作方面，用户可以通过将子图形拖拽在容器内或容器外轻松实现将子图形加入或移出容器，通过拖拽容器可以实现容器内子图形的一起移动。因此，容器尤其适用于图表、流程图、组织结构图的设计。\n但是，容器作为 Visio2010 的新增特性，Visio 并没有提供关于自定义容器的相关教程及建议，这也使得当前 Visio 容器的定义存在极高的自由度。通常，若将一个对象定义为容器，只需要在该对象 Spreadsheet 中的 User Section 内增加msvStructureType属性，并设置其值为=\u0026quot;Container\u0026quot;。\n但是，这种简单的定义可能会在特定情况下引发意外的文件尾错误。\n问题描述 星期一的时候，我的同事向我演示了他是如何引起这个错误的。首先，他将一条表示管路的线段放在了表示功能单元的容器内。由于这条管路表示外部进来的管路，所以他希望这条线段一端恰好贴在容器边框，另一端落在容器内。随后，他又删除了这条线段。在此之后，当他想要调整容器的尺寸时，出现了这个错误。 当我尝试复现这个错误时，我发现使用 Visio 预定义的容器并不会引发该现象。\n原因分析 通过仔细对比我们自定义的容器和 Visio 预定义的容器，我们确定了以下两个前置条件：\n线段一端必须吸附在容器的几何形状上。当线段被吸附至容器的几何形状上时，点击容器，连接处可以看到如图所示的高亮的连接点。 在默认状态下，拖拽线段至容器的边界不会引发吸附，除非文档模板中预定义或用户手动开启了该功能。该功能位于 View-Visual aids-Snap \u0026amp; Glue-General-Glue to节，勾选 Shape geometery 可以启用该功能。\n被吸附的容器的几何形状必须定义在容器本身，而不是容器组合的子对象。也就是说，表示几何形状的 Geometry Section 位于容器的 Spreadsheet 内。 解决方法 要解决这个问题，我们需要将容器的几何形状定义在容器组合的子对象中。也就是说，在创建自定义容器时，不应在容器自身的 Spreadsheet 中定义 Geometry，而应将容器转换为组合，并将表示容器几何形状的对象作为容器组合的子对象。\n以下给出了建议的自定义容器步骤：\n插入表示容器造型的形状对象； 将这些形状对象使用 Ctrl+G组合成一个组合对象； 打开组合对象的 Spreadsheet，并在 User Section 内增加msvStructureType属性，并设置其值为=\u0026quot;Container\u0026quot;。 ","permalink":"http://localhost:1313/posts/%E4%BF%AE%E5%A4%8Dvisio%E5%AE%B9%E5%99%A8%E8%B0%83%E6%95%B4%E5%B0%BA%E5%AF%B8%E5%BC%95%E5%8F%91%E7%9A%84%E6%84%8F%E5%A4%96%E7%9A%84%E6%96%87%E4%BB%B6%E5%B0%BE%E9%94%99%E8%AF%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/","summary":"\u003cblockquote\u003e\n\u003cp\u003e2025.3.17更新：\n将文件另存为VSD格式，然后再另存为VSDX格式即可修复。\u003c/p\u003e\u003c/blockquote\u003e\n\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cp\u003e容器是 Visio 中一类可以帮助实现结构化组织和管理其它图形元素的特殊对象。通过容器，您可以将相关的子图形放置在一个框架内，以便更清晰地展示信息和关系。在管理员定义方面，与组合相比，容器可以实现更丰富的预定义内容：形状结构、外观样式、连接点定义等，以满足不同公司对图表样式的要求。在用户操作方面，用户可以通过将子图形拖拽在容器内或容器外轻松实现将子图形加入或移出容器，通过拖拽容器可以实现容器内子图形的一起移动。因此，容器尤其适用于图表、流程图、组织结构图的设计。\u003c/p\u003e\n\u003cp\u003e但是，容器作为 Visio2010 的新增特性，Visio 并没有提供关于自定义容器的相关教程及建议，这也使得当前 Visio 容器的定义存在极高的自由度。通常，若将一个对象定义为容器，只需要在该对象 Spreadsheet 中的 User Section 内增加\u003ccode\u003emsvStructureType\u003c/code\u003e属性，并设置其值为\u003ccode\u003e=\u0026quot;Container\u0026quot;\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"create-a-container.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/F7hI19NnCyGziPt.png\"\u003e\n但是，这种简单的定义可能会在特定情况下引发\u003ccode\u003e意外的文件尾\u003c/code\u003e错误。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"unexpected-end-of-file.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/TYaG18djwNZW2sL.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"问题描述\"\u003e问题描述\u003c/h2\u003e\n\u003cp\u003e星期一的时候，我的同事向我演示了他是如何引起这个错误的。首先，他将一条表示管路的线段放在了表示功能单元的容器内。由于这条管路表示外部进来的管路，所以他希望这条线段一端恰好贴在容器边框，另一端落在容器内。随后，他又删除了这条线段。在此之后，当他想要调整容器的尺寸时，出现了这个错误。\n\u003cimg alt=\"a-line-in-the-container.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/7PwEGvabXVqdio6.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"error-when-resize-container-after-remove-line.png.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/bDJ3cExyn1Qehsk.png\"\u003e\u003c/p\u003e\n\u003cp\u003e当我尝试复现这个错误时，我发现使用 Visio 预定义的容器并不会引发该现象。\u003c/p\u003e\n\u003ch2 id=\"原因分析\"\u003e原因分析\u003c/h2\u003e\n\u003cp\u003e通过仔细对比我们自定义的容器和 Visio 预定义的容器，我们确定了以下两个前置条件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e线段一端必须吸附在容器的几何形状上。当线段被吸附至容器的几何形状上时，点击容器，连接处可以看到如图所示的高亮的连接点。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"glue-line-to-container-geometry.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/CDl6AM3PNg4HtLG.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在默认状态下，拖拽线段至容器的边界不会引发吸附，除非文档模板中预定义或用户手动开启了该功能。该功能位于 \u003ccode\u003eView\u003c/code\u003e-\u003ccode\u003eVisual aids\u003c/code\u003e-\u003ccode\u003eSnap \u0026amp; Glue\u003c/code\u003e-\u003ccode\u003eGeneral\u003c/code\u003e-\u003ccode\u003eGlue to\u003c/code\u003e节，勾选 Shape geometery 可以启用该功能。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"snap-and-glue.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/RVMuCWfdjAyXeiE.png\"\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e被吸附的容器的几何形状必须定义在容器本身，而不是容器组合的子对象。也就是说，表示几何形状的 Geometry Section 位于容器的 Spreadsheet 内。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"geometry-defined-in-container.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/imehkFnI6H94NzU.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e要解决这个问题，我们需要将容器的几何形状定义在容器组合的子对象中。也就是说，在创建自定义容器时，不应在容器自身的 Spreadsheet 中定义 Geometry，而应将容器转换为组合，并将表示容器几何形状的对象作为容器组合的子对象。\u003c/p\u003e\n\u003cp\u003e以下给出了建议的自定义容器步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e插入表示容器造型的形状对象；\u003c/li\u003e\n\u003cli\u003e将这些形状对象使用 \u003ccode\u003eCtrl+G\u003c/code\u003e组合成一个组合对象；\u003c/li\u003e\n\u003cli\u003e打开组合对象的 Spreadsheet，并在 User Section 内增加\u003ccode\u003emsvStructureType\u003c/code\u003e属性，并设置其值为\u003ccode\u003e=\u0026quot;Container\u0026quot;\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e","title":"修复Visio容器调整尺寸引发的意外的文件尾错误：正确的容器定义方法"}]