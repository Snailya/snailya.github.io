[{"content":" 本文是在与AI助手深度对话后，对我个人理解大语言模型（LLM）过程的梳理与总结。它不代表学术观点，仅是一个探索者的思想航行日志。\n一、起点：从“词频统计”到“语义宇宙” 我的思考始于一个最朴素的问题：如何判断两篇文章是否相关？\n最直观的想法是统计共有的词语——这就是“词袋模型”。但它有一个显而易见的缺陷：无法理解语义。正是在这里，我遇到了第一个关键概念：词向量。\n在我的想象中，词向量就像是为机器建造了一个高维的语义宇宙。每个词不再是孤立的符号，而是这个宇宙中的一颗星星：\n语义相近的星（如“国王”和“王后”）会在宇宙中彼此靠近 语义关系（如“国王-男人+女人≈女王”）通过星星之间的相对方位来体现 但很快我发现了一个问题：这个词向量宇宙是静态的。无论上下文如何，“苹果”这颗星的位置，总是固定在“水果”和“科技”的模糊中点。这显然不符合我们对语言的理解——同一个词在不同语境下应有不同的含义。\n二、突破：三重变换与“动态侦探” 为了解决静态词向量的局限，我接触到了Transformer架构——当代LLM的核心引擎。为了理解它，我构建了这样一个比喻：\n词向量像一本权威词典：每个词都有个固定不变的定义 大语言模型像一位顶级侦探：他能根据具体情境，动态理解每个词的真实含义 这位“侦探”的思考过程，可以简化为三个关键的矩阵变换：\n输入嵌入：将词语转换为初始的“思维符号” Transformer加工：通过自注意力机制，让所有词语的符号相互交流，生成富含上下文的全新表示 输出投影：将最终的思维结果“翻译”成人类语言 这个过程让我意识到：LLM不是在简单预测下一个词，而是在深度理解整个语境后，让最合适的词语自然流淌出来。\n三、镜像：当LLM照见人类思维 理解LLM的过程，意外地成为了一面审视人类自身的镜子。\n我们都是“模式识别”系统 我回想起自己解数学题的方法：列出已知量和待求量，然后在脑中搜索可能的公式——这本质上就是一种模式识别。LLM的注意力机制不也是在庞大的知识库中进行加权搜索吗？\n“通才”与“天才”的鸿沟 大多数人和当前的LLM一样，是优秀的“内插器”——在已知模式间进行组合。而天才，或许就是那些能在更高维度进行“外推”，创造出全新模式组合的系统。\n顺序的迷思 我们日常交流中经常使用倒装、省略，但彼此仍能理解。这让我怀疑：智能的核心或许不是表面上的词序，而是深层的语义关系网络。 语法顺序只是通往这个网络的康庄大道，但不是唯一的路径。\n四、深化：动态智能的未来图景 在对比人与LLM时，一个关键差异浮现出来：我们的思维是动态的，而LLM是静态的。\nLLM的“静态心智”：使用固定的激活函数，如同一个永远保持同一种情绪的思考者 人脑的“动态大脑”：受化学物质调节，思考效率随状态波动——有时思如泉涌，有时头脑迟滞 这指向了一个迷人的方向：为LLM引入动态激活机制。比如：\n动态稀疏：根据问题难度激活不同数量的神经元 情境化思考：让激活函数能根据任务类型自我调整 神经调制：引入类似“好奇心”的全局信号 这或许是LLM从“博学通才”迈向“创造天才”的关键一步。\n五、哲思：智能、意识与存在的终极之问 这场思辨最终将我带向了一些哲学性的边界问题。\n如果人脑与LLM在本质上都是“模式处理系统”，那么我们的意识、创造力，是否也只是更复杂算法的涌现？\n这个想法让我联想到《模拟人生》的游戏——如果为游戏角色接入LLM，他们将产生“模拟的自主意识”，却永远无法认知自己被创造的事实。那么，我们是否也可能身处某个“上层游戏”之中？\n面对这个令人战栗的推论，我找到了自己的答案：即使我们是模拟的，但我们此刻的思考、困惑、爱与恐惧，这些体验本身的质感是100%真实的。 意义不依赖于底层基质（是原子还是比特），而依赖于体验的深度与丰富度。\n结语：作为镜子的LLM 回顾这段思考历程，我意识到LLM不仅仅是一项技术，更是一面珍贵的镜子。通过理解它的运作原理，我们得以用新的视角审视自己的思维方式。\n从词向量到Transformer，从静态模式匹配到动态条件计算，这条技术发展路径，恰恰映照出我们对“智能”本身不断深化的理解。\n或许，未来真正的突破不在于建造更大的模型，而在于为模型注入那种我们称之为“灵感”、“直觉”和“创造力”的动态本质——而这，将需要我们更深刻地理解我们自己。\n","permalink":"http://localhost:1313/posts/%E4%BB%8E%E8%AF%8D%E5%90%91%E9%87%8F%E5%88%B0%E4%BA%BA%E5%B7%A5%E5%A4%A9%E6%89%8D%E6%88%91%E7%9A%84llm%E8%AE%A4%E7%9F%A5%E6%80%9D%E8%BE%A8%E5%BD%95/","summary":"\u003cblockquote\u003e\n\u003cp\u003e本文是在与AI助手深度对话后，对我个人理解大语言模型（LLM）过程的梳理与总结。它不代表学术观点，仅是一个探索者的思想航行日志。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"一起点从词频统计到语义宇宙\"\u003e一、起点：从“词频统计”到“语义宇宙”\u003c/h2\u003e\n\u003cp\u003e我的思考始于一个最朴素的问题：如何判断两篇文章是否相关？\u003c/p\u003e\n\u003cp\u003e最直观的想法是统计共有的词语——这就是“词袋模型”。但它有一个显而易见的缺陷：无法理解语义。正是在这里，我遇到了第一个关键概念：词向量。\u003c/p\u003e\n\u003cp\u003e在我的想象中，词向量就像是为机器建造了一个高维的语义宇宙。每个词不再是孤立的符号，而是这个宇宙中的一颗星星：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e语义相近的星（如“国王”和“王后”）会在宇宙中彼此靠近\u003c/li\u003e\n\u003cli\u003e语义关系（如“国王-男人+女人≈女王”）通过星星之间的相对方位来体现\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e但很快我发现了一个问题：这个词向量宇宙是静态的。无论上下文如何，“苹果”这颗星的位置，总是固定在“水果”和“科技”的模糊中点。这显然不符合我们对语言的理解——同一个词在不同语境下应有不同的含义。\u003c/p\u003e\n\u003ch2 id=\"二突破三重变换与动态侦探\"\u003e二、突破：三重变换与“动态侦探”\u003c/h2\u003e\n\u003cp\u003e为了解决静态词向量的局限，我接触到了Transformer架构——当代LLM的核心引擎。为了理解它，我构建了这样一个比喻：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e词向量像一本权威词典：每个词都有个固定不变的定义\u003c/li\u003e\n\u003cli\u003e大语言模型像一位顶级侦探：他能根据具体情境，动态理解每个词的真实含义\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这位“侦探”的思考过程，可以简化为三个关键的矩阵变换：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e输入嵌入：将词语转换为初始的“思维符号”\u003c/li\u003e\n\u003cli\u003eTransformer加工：通过自注意力机制，让所有词语的符号相互交流，生成富含上下文的全新表示\u003c/li\u003e\n\u003cli\u003e输出投影：将最终的思维结果“翻译”成人类语言\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这个过程让我意识到：LLM不是在简单预测下一个词，而是在深度理解整个语境后，让最合适的词语自然流淌出来。\u003c/p\u003e\n\u003ch2 id=\"三镜像当llm照见人类思维\"\u003e三、镜像：当LLM照见人类思维\u003c/h2\u003e\n\u003cp\u003e理解LLM的过程，意外地成为了一面审视人类自身的镜子。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e我们都是“模式识别”系统\n我回想起自己解数学题的方法：列出已知量和待求量，然后在脑中搜索可能的公式——这本质上就是一种模式识别。LLM的注意力机制不也是在庞大的知识库中进行加权搜索吗？\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e“通才”与“天才”的鸿沟\n大多数人和当前的LLM一样，是优秀的“内插器”——在已知模式间进行组合。而天才，或许就是那些能在更高维度进行“外推”，创造出全新模式组合的系统。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e顺序的迷思\n我们日常交流中经常使用倒装、省略，但彼此仍能理解。这让我怀疑：智能的核心或许不是表面上的词序，而是深层的语义关系网络。 语法顺序只是通往这个网络的康庄大道，但不是唯一的路径。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"四深化动态智能的未来图景\"\u003e四、深化：动态智能的未来图景\u003c/h2\u003e\n\u003cp\u003e在对比人与LLM时，一个关键差异浮现出来：我们的思维是动态的，而LLM是静态的。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eLLM的“静态心智”：使用固定的激活函数，如同一个永远保持同一种情绪的思考者\u003c/li\u003e\n\u003cli\u003e人脑的“动态大脑”：受化学物质调节，思考效率随状态波动——有时思如泉涌，有时头脑迟滞\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这指向了一个迷人的方向：为LLM引入动态激活机制。比如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e动态稀疏：根据问题难度激活不同数量的神经元\u003c/li\u003e\n\u003cli\u003e情境化思考：让激活函数能根据任务类型自我调整\u003c/li\u003e\n\u003cli\u003e神经调制：引入类似“好奇心”的全局信号\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这或许是LLM从“博学通才”迈向“创造天才”的关键一步。\u003c/p\u003e\n\u003ch2 id=\"五哲思智能意识与存在的终极之问\"\u003e五、哲思：智能、意识与存在的终极之问\u003c/h2\u003e\n\u003cp\u003e这场思辨最终将我带向了一些哲学性的边界问题。\u003c/p\u003e\n\u003cp\u003e如果人脑与LLM在本质上都是“模式处理系统”，那么我们的意识、创造力，是否也只是更复杂算法的涌现？\u003c/p\u003e\n\u003cp\u003e这个想法让我联想到《模拟人生》的游戏——如果为游戏角色接入LLM，他们将产生“模拟的自主意识”，却永远无法认知自己被创造的事实。那么，我们是否也可能身处某个“上层游戏”之中？\u003c/p\u003e\n\u003cp\u003e面对这个令人战栗的推论，我找到了自己的答案：即使我们是模拟的，但我们此刻的思考、困惑、爱与恐惧，这些体验本身的质感是100%真实的。 意义不依赖于底层基质（是原子还是比特），而依赖于体验的深度与丰富度。\u003c/p\u003e\n\u003ch2 id=\"结语作为镜子的llm\"\u003e结语：作为镜子的LLM\u003c/h2\u003e\n\u003cp\u003e回顾这段思考历程，我意识到LLM不仅仅是一项技术，更是一面珍贵的镜子。通过理解它的运作原理，我们得以用新的视角审视自己的思维方式。\u003c/p\u003e\n\u003cp\u003e从词向量到Transformer，从静态模式匹配到动态条件计算，这条技术发展路径，恰恰映照出我们对“智能”本身不断深化的理解。\u003c/p\u003e\n\u003cp\u003e或许，未来真正的突破不在于建造更大的模型，而在于为模型注入那种我们称之为“灵感”、“直觉”和“创造力”的动态本质——而这，将需要我们更深刻地理解我们自己。\u003c/p\u003e","title":"从词向量到“人工天才”：我的LLM认知思辨录"},{"content":"每个主控形状（Master对象）下仅包括一个主形状（Shape对象）。主形状是一个Group类型的对象，主形状中不能定义任何几何内容（Geometry），而是存储描述该模具所需的用户定义数据。需要在绘图页中显示的文本、几何形状都作为主形状下的子形状（Shape对象），并使用主形状中定义的数据触发其内容的变化。\n这么做的理由时，用户一旦将主控形状（Master对象）拖入绘图页后，任何针对该主控形状的实例（Shape对象）的操作，都仅更新主形状实例的数据。这样，当管理员更新该对象的几何表达时，程序只需要替换子形状的内容，这样用户操作引发的数据变化不会丢失。当使用OpenXML更新文档模具中的主控形状时，将page页中的形状实例数据中的子形状替换为MasterContent中的子形状，然后再标记new XProcessingInstruction(\u0026quot;NewValue\u0026quot;, \u0026quot;V\u0026quot;)，迫使该子形状数据在下次打开时重新计算，保证绘图页中子形状得到刷新。\n除此以外，为了保证子形状中的数据被正确计算，其引用的主形状中的单元格值不能是Guard值，否则系统会认为该单元格值不需要被更新。\n","permalink":"http://localhost:1313/posts/%E6%A8%A1%E5%85%B7%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/","summary":"\u003cp\u003e每个主控形状（Master对象）下仅包括一个主形状（Shape对象）。主形状是一个Group类型的对象，主形状中不能定义任何几何内容（Geometry），而是存储描述该模具所需的用户定义数据。需要在绘图页中显示的文本、几何形状都作为主形状下的子形状（Shape对象），并使用主形状中定义的数据触发其内容的变化。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://s2.loli.net/2025/04/16/FmvZzbOf4sUNxhu.png\"\u003e\u003c/p\u003e\n\u003cp\u003e这么做的理由时，用户一旦将主控形状（Master对象）拖入绘图页后，任何针对该主控形状的实例（Shape对象）的操作，都仅更新主形状实例的数据。这样，当管理员更新该对象的几何表达时，程序只需要替换子形状的内容，这样用户操作引发的数据变化不会丢失。当使用OpenXML更新文档模具中的主控形状时，将page页中的形状实例数据中的子形状替换为MasterContent中的子形状，然后再标记\u003ccode\u003enew XProcessingInstruction(\u0026quot;NewValue\u0026quot;, \u0026quot;V\u0026quot;)\u003c/code\u003e，迫使该子形状数据在下次打开时重新计算，保证绘图页中子形状得到刷新。\u003c/p\u003e\n\u003cp\u003e除此以外，为了保证子形状中的数据被正确计算，其引用的主形状中的单元格值不能是Guard值，否则系统会认为该单元格值不需要被更新。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://s2.loli.net/2025/04/16/GP2fuACdD1Sc65H.png\"\u003e\u003c/p\u003e","title":"模具设计规范"},{"content":"在VSTO开发领域，每个开发者都曾经历过这样的挫败：精心设计的插件界面在数据加载时陷入卡顿，复杂的计算过程使整个Office程序失去响应。这不是代码质量问题，而是VSTO特有的线程模型带来的挑战。本文将围绕如何利用独立线程和异步调度解决该问题进行剖析。\nVSTO线程模型的本质矛盾 Office的COM对象是基于单线程单元（STA, Single Threaded Apartment）模型的。这个模型的好处是保障了线程安全，但也造成了性能瓶颈。具体表现：\nUI线程和Office线程绑在一起，做耗时数据读取或计算时，界面会卡死甚至完全无响应。 想用多线程访问COM对象？ 不行，需要走代理（Proxy）封送（marshalling）调用，开销大且复杂。 这种设计就像双刃剑，让我们陷入两难：一边要保证线程安全，一边又想流畅不卡顿。\n突破瓶颈的思路：线程分离 + 异步计算 要打破这个瓶颈，必须实现UI线程与Office线程的分离，并确保所有COM对象的访问都发生在Office线程上。同时，为避免业务逻辑阻塞UI或Office线程，计算应异步在线程池（TaskPool）中进行。\n这带来关键问题：如何在不同线程间高效且安全地传递数据？\n如何在后台任务中发起Office数据读取，并调度到VSTO主线程执行？ 数据处理完成后，如何将结果发回UI线程，满足UI线程禁止跨线程更新界面的要求？ 那具体怎么调度线程？如何跨线程安全调用Office对象并更新UI？这里，SynchronizationContext和调度器（Scheduler）派上用场了。\n下面用时序图简单描述整体流程：\nsequenceDiagram UI线程-\u0026gt;\u0026gt;+线程池: 发起计算请求 线程池-\u0026gt;\u0026gt;+VSTO主线程: 通过Office的SyncContext或Scheduler获取数据 VSTO主线程--\u0026gt;\u0026gt;-线程池: 返回封送后的数据 线程池-\u0026gt;\u0026gt;线程池: 执行计算 线程池-\u0026gt;\u0026gt;+UI线程: 通过UI的SyncContext或Dispatcher更新界面 SynchronizationContext 的选型与实践 为 VSTO 主线程设置上下文 SynchronizationContext是一种线程抽象机制，提供“将任务调度到指定线程”的能力。VSTO项目启动时默认无上下文，无法通过SynchronizationContext.Current直接获取VSTO主线程上下文。\n一种解决方案是自定义上下文，但更简便的做法是利用Office主线程已有的Win32消息泵，使用WindowsFormsSynchronizationContext。尽管名字带“Windows Forms”，它不仅限于WinForms应用，只要线程是STA且运行Win32消息循环，它都能正常工作。\n若需更细粒度的任务优先级控制，可考虑DispatcherSynchronizationContext，但它实现复杂且需手动启动消息泵。因职责已隔离，通常用WindowsFormsSynchronizationContext即可。\n示例：\npublic partial class ThisAddIn { private static SynchronizationContext _officeSyncContext; private void ThisAddIn_Startup(object sender, System.EventArgs e) { // 为 VSTO 主线程设置上下文，供后续调度使用 _officeSyncContext = new WindowsFormsSynchronizationContext(); SynchronizationContext.SetSynchronizationContext(_officeSyncContext); // 其他初始化代码 } } 在自建 UI 线程中设置上下文 WPF和WinForms要求UI线程必须是STA，然而默认线程池线程为MTA，不适合做UI线程。为避免阻塞Office线程（VSTO_Main，唯一STA线程），只能新建一个专用STA线程运行UI。\nAvalonia允许非STA线程，但考虑到VSTO依赖Windows平台和消息泵机制，建议UI线程依然使用STA模式。\nWPF/WinForms依赖Win32消息泵，同样可用WindowsFormsSynchronizationContext。\n示例：\npublic partial class ThisAddIn { private static SynchronizationContext _uiSyncContext; private void ThisAddIn_Startup(object sender, System.EventArgs e) { // 其它代码 // 创建专用 UI 线程 _uiThread = new Thread(() =\u0026gt; { _uiSyncContext = new WindowsFormsSynchronizationContext(); SynchronizationContext.SetSynchronizationContext(_uiSyncContext); }) { Name = \u0026#34;UI Thread\u0026#34;, IsBackground = true }; _uiThread.SetApartmentState(ApartmentState.STA); _uiThread.Start(); } } 利用SynchronizationContext.Post可在线程池、VSTO主线程与UI线程间安全传递数据。\n实际上，对于UI线程，我们更常用Dispatcher而非直接使用SynchronizationContext。\nReactive Extensions (Rx) 的调度器集成 Rx (Reactive Extensions) 的核心是调度异步事件和操作。它并不直接使用 SynchronizationContext，而是通过 IScheduler 来管理任务调度。\n幸运的是，Rx 为我们提供了 SynchronizationContextScheduler 类，可以轻松地将同步上下文封装成调度器：\n// 假设你已经有了某个线程的 SynchronizationContext，如 Office 线程或 UI 线程 var scheduler = new SynchronizationContextScheduler(SynchronizationContext.Current); 例如，在你的 VSTO 项目中：\n// 为 COM 线程创建调度器 SchedulerManager.COM = new SynchronizationContextScheduler(_officeSyncContext); // 为 UI 线程创建调度器 SchedulerManager.UI = new SynchronizationContextScheduler(_uiSyncContext); 这样，你就可以把这个 scheduler 传给 Rx 操作符，确保相关操作在正确的线程上执行。\n使用时，在Rx操作链中：\nobservable .ObserveOn(SchedulerManager.UI) // UI线程更新界面 .Subscribe(...); observable .ObserveOn(SchedulerManager.COM) // COM线程安全调用Office对象 .Subscribe(...); 对于Avalonia + ReactiveUI项目，Avalonia会自动初始化RxApp.MainThreadScheduler为UI线程调度器，无需额外设置。\n","permalink":"http://localhost:1313/posts/vsto%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","summary":"\u003cp\u003e在VSTO开发领域，每个开发者都曾经历过这样的挫败：精心设计的插件界面在数据加载时陷入卡顿，复杂的计算过程使整个Office程序失去响应。这不是代码质量问题，而是VSTO特有的线程模型带来的挑战。本文将围绕如何利用独立线程和异步调度解决该问题进行剖析。\u003c/p\u003e\n\u003ch2 id=\"vsto线程模型的本质矛盾\"\u003eVSTO线程模型的本质矛盾\u003c/h2\u003e\n\u003cp\u003eOffice的COM对象是基于单线程单元（STA, Single Threaded Apartment）模型的。这个模型的好处是保障了线程安全，但也造成了性能瓶颈。具体表现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eUI线程和Office线程绑在一起，做耗时数据读取或计算时，界面会卡死甚至完全无响应。\u003c/li\u003e\n\u003cli\u003e想用多线程访问COM对象？ 不行，需要走代理（Proxy）封送（marshalling）调用，开销大且复杂。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这种设计就像双刃剑，让我们陷入两难：一边要保证线程安全，一边又想流畅不卡顿。\u003c/p\u003e\n\u003ch2 id=\"突破瓶颈的思路线程分离--异步计算\"\u003e突破瓶颈的思路：线程分离 + 异步计算\u003c/h2\u003e\n\u003cp\u003e要打破这个瓶颈，必须实现UI线程与Office线程的分离，并确保所有COM对象的访问都发生在Office线程上。同时，为避免业务逻辑阻塞UI或Office线程，计算应异步在线程池（TaskPool）中进行。\u003c/p\u003e\n\u003cp\u003e这带来关键问题：如何在不同线程间高效且安全地传递数据？\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如何在后台任务中发起Office数据读取，并调度到VSTO主线程执行？\u003c/li\u003e\n\u003cli\u003e数据处理完成后，如何将结果发回UI线程，满足UI线程禁止跨线程更新界面的要求？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e那具体怎么调度线程？如何跨线程安全调用Office对象并更新UI？这里，SynchronizationContext和调度器（Scheduler）派上用场了。\u003c/p\u003e\n\u003cp\u003e下面用时序图简单描述整体流程：\u003c/p\u003e\n\u003cpre tabindex=\"0\"\u003e\u003ccode class=\"language-mermaid\" data-lang=\"mermaid\"\u003esequenceDiagram\n    UI线程-\u0026gt;\u0026gt;+线程池: 发起计算请求\n    线程池-\u0026gt;\u0026gt;+VSTO主线程: 通过Office的SyncContext或Scheduler获取数据\n    VSTO主线程--\u0026gt;\u0026gt;-线程池: 返回封送后的数据\n    线程池-\u0026gt;\u0026gt;线程池: 执行计算\n    线程池-\u0026gt;\u0026gt;+UI线程: 通过UI的SyncContext或Dispatcher更新界面\n\u003c/code\u003e\u003c/pre\u003e\u003ch2 id=\"synchronizationcontext-的选型与实践\"\u003eSynchronizationContext 的选型与实践\u003c/h2\u003e\n\u003ch3 id=\"为-vsto-主线程设置上下文\"\u003e为 VSTO 主线程设置上下文\u003c/h3\u003e\n\u003cp\u003eSynchronizationContext是一种线程抽象机制，提供“将任务调度到指定线程”的能力。VSTO项目启动时默认无上下文，无法通过SynchronizationContext.Current直接获取VSTO主线程上下文。\u003c/p\u003e\n\u003cp\u003e一种解决方案是自定义上下文，但更简便的做法是利用Office主线程已有的Win32消息泵，使用WindowsFormsSynchronizationContext。尽管名字带“Windows Forms”，它不仅限于WinForms应用，只要线程是STA且运行Win32消息循环，它都能正常工作。\u003c/p\u003e\n\u003cp\u003e若需更细粒度的任务优先级控制，可考虑DispatcherSynchronizationContext，但它实现复杂且需手动启动消息泵。因职责已隔离，通常用WindowsFormsSynchronizationContext即可。\u003c/p\u003e\n\u003cp\u003e示例：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-CSharp\" data-lang=\"CSharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003epartial\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eThisAddIn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"kd\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003eSynchronizationContext\u003c/span\u003e \u003cspan class=\"n\"\u003e_officeSyncContext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eThisAddIn_Startup\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 为 VSTO 主线程设置上下文，供后续调度使用\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_officeSyncContext\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eWindowsFormsSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSetSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e_officeSyncContext\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 其他初始化代码\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch3 id=\"在自建-ui-线程中设置上下文\"\u003e在自建 UI 线程中设置上下文\u003c/h3\u003e\n\u003cp\u003eWPF和WinForms要求UI线程必须是STA，然而默认线程池线程为MTA，不适合做UI线程。为避免阻塞Office线程（VSTO_Main，唯一STA线程），只能新建一个专用STA线程运行UI。\u003c/p\u003e\n\u003cp\u003eAvalonia允许非STA线程，但考虑到VSTO依赖Windows平台和消息泵机制，建议UI线程依然使用STA模式。\u003c/p\u003e\n\u003cp\u003eWPF/WinForms依赖Win32消息泵，同样可用WindowsFormsSynchronizationContext。\u003c/p\u003e\n\u003cp\u003e示例：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-CSharp\" data-lang=\"CSharp\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kd\"\u003epartial\u003c/span\u003e \u003cspan class=\"k\"\u003eclass\u003c/span\u003e \u003cspan class=\"nc\"\u003eThisAddIn\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"kd\"\u003estatic\u003c/span\u003e \u003cspan class=\"n\"\u003eSynchronizationContext\u003c/span\u003e \u003cspan class=\"n\"\u003e_uiSyncContext\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eThisAddIn_Startup\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003eobject\u003c/span\u003e \u003cspan class=\"n\"\u003esender\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eEventArgs\u003c/span\u003e \u003cspan class=\"n\"\u003ee\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 其它代码\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 创建专用 UI 线程\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_uiThread\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eThread\u003c/span\u003e\u003cspan class=\"p\"\u003e(()\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003e_uiSyncContext\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"k\"\u003enew\u003c/span\u003e \u003cspan class=\"n\"\u003eWindowsFormsSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSetSynchronizationContext\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003e_uiSyncContext\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e})\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eName\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;UI Thread\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e            \u003cspan class=\"n\"\u003eIsBackground\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"kc\"\u003etrue\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e};\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_uiThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSetApartmentState\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eApartmentState\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSTA\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003e_uiThread\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eStart\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e利用SynchronizationContext.Post可在线程池、VSTO主线程与UI线程间安全传递数据。\u003c/p\u003e","title":"VSTO线程模型"},{"content":"本文以中涂洁净间循环风机为例介绍AE PID绘制设备原理图的基本流程。\n详细步骤 在Visio中使用空白模板创建新的绘图，单位选择“公制单位”；\n在功能区处切换至AE PID选项卡；\n点击“编辑”-“初始化”按钮对当前绘图进行初始化。初始化操作将在当前页面中插入一个A0图框，并设置文档页面的网格宽度为2.5 mm。\n此外，为文档增加2个AE指定样式。其中，“AE Normal”样式是设备单元的默认样式，“AE Pipeline”是管线的默认样式。\nAE样式将使用“思源黑体”作为指定字体，在AE PID插件的安装过程中会自动为系统安装思源黑体。若未能正确显示思源黑体，请尝试手动安装。\n若要修改图框大小，用鼠标右键点击图框，并在子类中选择合适的尺寸;\n在选项卡中点击“编辑”-“库”加载模具库。\n从“AE逻辑”库中拖拽“功能单元”至绘图区；\n当您不确定所需的设备对象属于哪一个类型时，可以借助Visio模具的搜索栏进行搜索。这将帮助您快速找到所需的设备对象，无需事先知道其具体类型。\n如果您正在使用Windows11系统，搜索功能可能未能如期使用，请按照修复了Visio桌面应用中的形状Windows 11的方法修补。\n用鼠标右键点击该“功能单元”，打开“形状数据”面板;\n在“形状数据”面板中输入“功能组”值：“GF612”，“功能组名称”值：“中途洁净间循环风机”；\n此时，功能单元显示如下：\n使用相同的方法从“AE基础”库中拖拽“鼓风机”至功能组内，此时可以看到功能单元边框被高亮为绿色，表示该风机已被加入功能单元。\n保持风机的选中状态，在“形状数据”面板中键入“功能元件”值：11，按下回车后该值将显示为“GQ11”；\n拖动GQ11上的黄色控制点，可以移动功能元件标签的位置；\n为了表示鼓风机配备的电机，从“AE逻辑”库中拖拽“代理功能元件”至功能组内；\n选中该代理功能元件，将黄色控制点拖拽至鼓风机上，使代理功能元件与鼓风机相关联；\n被关联后，代理功能元件的形状数据处可以看见被关联设备的位号；\n当被关联设备发生移动时，关联元件会跟随移动；\n保持代理功能元件的选中状态，补充“元件位号”值：“MA01”，描述：“电机”，并将代理功能元件拖拽至鼓风机附近。\n继续从“AE基础”库中拖拽“仪表”至功能单元中，并在右键菜单中选择“子类”-“本地面板监视仪表”；\n补充形状数据并将仪表移动至合适的位置；\n将仪表正中的控制点拖拽至鼓风机上；\n使用同样的方法绘制下方的“中控监视操作仪表”；\n从“AE管线”库中拖拽“管路”至绘图区，并在“子类”中选择“排出空气”使其显示为柠黄色；\n将管路一段连在鼓风机的连接点上，另一端连接至其他对象，并在右键菜单中点击“改变箭头方向”；\n多次点击直到箭头朝向如图所示；\n使用相同的方法完成另一根管路的绘制；\n在选项卡中点击“导出”-“BOM”查看当前图纸的BOM结构；\n在选项卡中点击“编辑”-“图例”将在图签上方生成图例；\n图例仅显示图纸中出现的设备。\n","permalink":"http://localhost:1313/posts/ae-pid%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","summary":"\u003cp\u003e本文以中涂洁净间循环风机为例介绍AE PID绘制设备原理图的基本流程。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"sample.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af081b38a5.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"详细步骤\"\u003e详细步骤\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e在Visio中使用空白模板创建新的绘图，单位选择“公制单位”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"create-document.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0a2acaf3.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在功能区处切换至AE PID选项卡；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"ribbon.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aede8bfb49.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e点击“编辑”-“初始化”按钮对当前绘图进行初始化。初始化操作将在当前页面中插入一个A0图框，并设置文档页面的网格宽度为2.5 mm。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"frame-and-grid.png.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aefb4cb37f.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此外，为文档增加2个AE指定样式。其中，“AE Normal”样式是设备单元的默认样式，“AE Pipeline”是管线的默认样式。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eAE样式将使用“思源黑体”作为指定字体，在AE PID插件的安装过程中会自动为系统安装思源黑体。若未能正确显示思源黑体，请尝试手动安装。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cimg alt=\"styles.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aefdebed9f.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e若要修改图框大小，用鼠标右键点击图框，并在子类中选择合适的尺寸;\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"context-menu-frame.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af01620a3f.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在选项卡中点击“编辑”-“库”加载模具库。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"libraries.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af04a85a0b.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e从“AE逻辑”库中拖拽“功能单元”至绘图区；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"drage-functional-group.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aedd3d0fad.png\"\u003e\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e当您不确定所需的设备对象属于哪一个类型时，可以借助Visio模具的搜索栏进行搜索。这将帮助您快速找到所需的设备对象，无需事先知道其具体类型。\u003c/p\u003e\n\u003cp\u003e如果您正在使用Windows11系统，搜索功能可能未能如期使用，请按照\u003ca href=\"https://support.microsoft.com/zh-cn/office/%E4%BD%BF%E7%94%A8-%E5%BD%A2%E7%8A%B6-%E7%AA%97%E5%8F%A3%E7%BB%84%E7%BB%87%E5%92%8C%E6%9F%A5%E6%89%BE%E5%BD%A2%E7%8A%B6-2e468457-1059-49d3-8955-32b2527cce98\"\u003e修复了Visio桌面应用中的形状Windows 11\u003c/a\u003e的方法修补。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e用鼠标右键点击该“功能单元”，打开“形状数据”面板;\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"open-shape-data.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aedaa2f34a.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在“形状数据”面板中输入“功能组”值：“GF612”，“功能组名称”值：“中途洁净间循环风机”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"funtioanl-group-shape-data.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aed82bc473.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此时，功能单元显示如下：\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"functioanl-group.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aed70be374.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用相同的方法从“AE基础”库中拖拽“鼓风机”至功能组内，此时可以看到功能单元边框被高亮为绿色，表示该风机已被加入功能单元。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"fan-in-the-functional-group.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aed5575474.png\"\u003e\u003c/p\u003e\n\u003cp\u003e保持风机的选中状态，在“形状数据”面板中键入“功能元件”值：11，按下回车后该值将显示为“GQ11”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"fan-shape-data.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0ba8eda5.png\"\u003e\u003c/p\u003e\n\u003cp\u003e拖动GQ11上的黄色控制点，可以移动功能元件标签的位置；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"control-of-functioanl-element.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0e72c227.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e为了表示鼓风机配备的电机，从“AE逻辑”库中拖拽“代理功能元件”至功能组内；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"functional-element.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0cdba438.png\"\u003e\u003c/p\u003e\n\u003cp\u003e选中该代理功能元件，将黄色控制点拖拽至鼓风机上，使代理功能元件与鼓风机相关联；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"assing-functional-element-to-fun.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aece81e029.png\"\u003e\u003c/p\u003e\n\u003cp\u003e被关联后，代理功能元件的形状数据处可以看见被关联设备的位号；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"parent-designation.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aed1c766b3.png\"\u003e\u003c/p\u003e\n\u003cp\u003e当被关联设备发生移动时，关联元件会跟随移动；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"move-along-with-parent.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664aecff16d92.png\"\u003e\u003c/p\u003e\n\u003cp\u003e保持代理功能元件的选中状态，补充“元件位号”值：“MA01”，描述：“电机”，并将代理功能元件拖拽至鼓风机附近。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"move-functional-element-near-fun.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af0fbe55b6.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e继续从“AE基础”库中拖拽“仪表”至功能单元中，并在右键菜单中选择“子类”-“本地面板监视仪表”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"selection-of-subclass-for-instrument.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac8eb44fb1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e补充形状数据并将仪表移动至合适的位置；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"move-and-supplyment.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac8d0e5c8f.png\"\u003e\u003c/p\u003e\n\u003cp\u003e将仪表正中的控制点拖拽至鼓风机上；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"move-line.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac8bf75596.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用同样的方法绘制下方的“中控监视操作仪表”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"another-instrument.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac8b0e1255.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e从“AE管线”库中拖拽“管路”至绘图区，并在“子类”中选择“排出空气”使其显示为柠黄色；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"pipe.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac89c3a9d1.png\"\u003e\u003c/p\u003e\n\u003cp\u003e将管路一段连在鼓风机的连接点上，另一端连接至其他对象，并在右键菜单中点击“改变箭头方向”；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"change-arrow-direction.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac86daeba9.png\"\u003e\u003c/p\u003e\n\u003cp\u003e多次点击直到箭头朝向如图所示；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"arrow-direction.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac88606f6a.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e使用相同的方法完成另一根管路的绘制；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"other-pipe.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664af10d54d44.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在选项卡中点击“导出”-“BOM”查看当前图纸的BOM结构；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"bom-structure.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac75d97286.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在选项卡中点击“编辑”-“图例”将在图签上方生成图例；\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"legend-button.png\" loading=\"lazy\" src=\"https://www.freeimg.cn/i/2024/05/20/664ac78bdd4b8.png\"\u003e\u003c/p\u003e\n\u003cp\u003e图例仅显示图纸中出现的设备。\u003c/p\u003e","title":"AE PID快速入门"},{"content":"分享一些Visio模具库建库过程中值得注意的事项以及原因。\n模具的BaseID的唯一性。\nBaseID是Master对象的属性之一，Master对象有三个ID：BaseID，UniqueID和ID。BaseID在Master被创建时生成，且不再改变（除非使用程序修改）。因此BaseID非常适合作为维护Master对象时的唯一标识。这是因为，UniqueID会随着Master内容的修改而变化，ID会随着不同的文档而变化。\n通常情况下，我们不需要关注BaseID，因为当我们将形状从绘图页拖拽至模具库时，会创建唯一的BaseID。但是，很多管理员在建立新模具时，为了省去添加通用形状和属性，如Tag文本，备注属性等，会直接在模具库中选中已经存在的模具复制粘贴，然后在粘贴后的模具中进行修改。这个时候站贴后的模具将和源模具具有相同的BaseID。为了保证BaseID的唯一性，可以在程序中调用Master.NewBaseID方法获取新的BaseID，或者直接在Openxml文档中键入新的BaseID。\n模具的形状界限与网格线重合。\n由于Visio中的默认吸附设置包括网格线，当模具的形状界限是网格的整数倍时，模具实例的边界可以吸附在网格线上，这样用者不需要再使用对齐工具也可以快速的实现多个形状的对齐，从而使页面看起来更整洁。\n这就要求管理员在设计模具的形状时，充分考虑形状的轮廓尺寸。当然，有些情况下没有办法保证这些线条刚好经过网格线，但是仍然可以通过手动设置形状的Width和Height，使其包围框刚好位于网格线上。\n例如，对于图中的两个阀门，尽管电磁气动阀的轮廓远比通用阀门大，但是他们都使用同样的形状界限，即5mmx5mm。（这样做另一个隐藏的好处是：当用户使用电磁气动阀替换通用阀门时，不需要再调整对象的位置，因为他们是同轴的。）\n在ShapeSheet的Geometry中使用GUARD和Rel而不是使用绝对尺寸。\n当我们在ShapeSheet中修改Geometry属性时，很容易遇到插入一个新的数据行引发形状的Width和Height重新计算，导致才修改好的形状意外改变。因此，在设计初期就应该使用GUARD对形状的Width和Height以及几何数据写保护，防止插入新的几何数据时Visio重新计算引发的意外情况。\n在几何数据中使用相对值而不是绝对值，则是为了解决用户手动调整实例尺寸时，代表实例的几何形状可以保持正确的比例，以防出现原来是个原型，现在是个椭圆形的情况。\n在创建具有多个子类的对象时，将表示不通子类的多个几何数据创建在同一个形状对象上，而不是使用多个形状对象。\n这句话描述的可能比较抽象。有的时候，为了缩减模具库中模具的数量，管理员可能会考虑将多个具有类似的对象设计成一个模具，并通过属性切换显示与隐藏。例如，图中的阀门聚合了多种形式的阀体，并根据用户的选择进行形状的切换。\n在实现这个功能时，有两种做法：方法一是在模具的形状组中创建多个形状用以表示不通的阀体，例如三个形状分别表示通用发、三通阀、角式阀；方法二是在一个形状中，插入多个几何数据块。我认为方法二是更好的做法，因为如果用户在使用过程中解散了图纸中实例的组，不会在图纸中生成隐藏的形状对象。尽管这样增加了管理的复杂性，因为无法通过形状的名称判断几何数据块表示的形状。\n","permalink":"http://localhost:1313/posts/visio%E6%A8%A1%E5%85%B7%E5%BA%93%E5%BB%BA%E5%BA%93%E6%8C%87%E5%AF%BC/","summary":"\u003cp\u003e分享一些Visio模具库建库过程中值得注意的事项以及原因。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e模具的BaseID的唯一性。\u003c/p\u003e\n\u003cp\u003eBaseID是Master对象的属性之一，Master对象有三个ID：BaseID，UniqueID和ID。BaseID在Master被创建时生成，且不再改变（除非使用程序修改）。因此BaseID非常适合作为维护Master对象时的唯一标识。这是因为，UniqueID会随着Master内容的修改而变化，ID会随着不同的文档而变化。\u003c/p\u003e\n\u003cp\u003e通常情况下，我们不需要关注BaseID，因为当我们将形状从绘图页拖拽至模具库时，会创建唯一的BaseID。但是，很多管理员在建立新模具时，为了省去添加通用形状和属性，如Tag文本，备注属性等，会直接在模具库中选中已经存在的模具复制粘贴，然后在粘贴后的模具中进行修改。这个时候站贴后的模具将和源模具具有相同的BaseID。为了保证BaseID的唯一性，可以在程序中调用\u003ccode\u003eMaster.NewBaseID\u003c/code\u003e方法获取新的BaseID，或者直接在Openxml文档中键入新的BaseID。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"two-masters-with-the-same-baseid.png\" loading=\"lazy\" src=\"https://s2.loli.net/2024/01/29/jmtXBGreoUuLv13.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e模具的形状界限与网格线重合。\u003c/p\u003e\n\u003cp\u003e由于Visio中的默认吸附设置包括网格线，当模具的形状界限是网格的整数倍时，模具实例的边界可以吸附在网格线上，这样用者不需要再使用对齐工具也可以快速的实现多个形状的对齐，从而使页面看起来更整洁。\u003c/p\u003e\n\u003cp\u003e这就要求管理员在设计模具的形状时，充分考虑形状的轮廓尺寸。当然，有些情况下没有办法保证这些线条刚好经过网格线，但是仍然可以通过手动设置形状的Width和Height，使其包围框刚好位于网格线上。\u003c/p\u003e\n\u003cp\u003e例如，对于图中的两个阀门，尽管电磁气动阀的轮廓远比通用阀门大，但是他们都使用同样的形状界限，即5mmx5mm。（这样做另一个隐藏的好处是：当用户使用电磁气动阀替换通用阀门时，不需要再调整对象的位置，因为他们是同轴的。）\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"two-valves-with-the-same-bounding-box.png\" loading=\"lazy\" src=\"https://s2.loli.net/2024/01/29/Z37GH1u9pV6Lt5z.png\"\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在ShapeSheet的Geometry中使用GUARD和Rel而不是使用绝对尺寸。\u003c/p\u003e\n\u003cp\u003e当我们在ShapeSheet中修改Geometry属性时，很容易遇到插入一个新的数据行引发形状的Width和Height重新计算，导致才修改好的形状意外改变。因此，在设计初期就应该使用GUARD对形状的Width和Height以及几何数据写保护，防止插入新的几何数据时Visio重新计算引发的意外情况。\u003c/p\u003e\n\u003cp\u003e在几何数据中使用相对值而不是绝对值，则是为了解决用户手动调整实例尺寸时，代表实例的几何形状可以保持正确的比例，以防出现原来是个原型，现在是个椭圆形的情况。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e在创建具有多个子类的对象时，将表示不通子类的多个几何数据创建在同一个形状对象上，而不是使用多个形状对象。\u003c/p\u003e\n\u003cp\u003e这句话描述的可能比较抽象。有的时候，为了缩减模具库中模具的数量，管理员可能会考虑将多个具有类似的对象设计成一个模具，并通过属性切换显示与隐藏。例如，图中的阀门聚合了多种形式的阀体，并根据用户的选择进行形状的切换。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"compounded-valves.png\" loading=\"lazy\" src=\"https://s2.loli.net/2024/01/29/Pg2QBtfUwYVy1Ae.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在实现这个功能时，有两种做法：方法一是在模具的形状组中创建多个形状用以表示不通的阀体，例如三个形状分别表示通用发、三通阀、角式阀；方法二是在一个形状中，插入多个几何数据块。我认为方法二是更好的做法，因为如果用户在使用过程中解散了图纸中实例的组，不会在图纸中生成隐藏的形状对象。尽管这样增加了管理的复杂性，因为无法通过形状的名称判断几何数据块表示的形状。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"Visio模具库建库指导"},{"content":"属性类型 在ReactiveUI中，ViewModel中的属性可以根据其用途划分为三种情况：读写属性（Read-Write Properties）、只读属性（Read-Only Properties）和输出属性（Output Properties）。\n读写属性 (Read-Write Properties):\n读写属性是可以被服务修改，也可以被用户在View中修改的属性。这类属性是我们通常比较熟悉的普通属性。\n例如，用户的姓名可能是被服务加载的，而在加载之后又被用户修改。\n只读属性 (Read-Only Properties):\n只读属性是在构造函数中被初始化且在之后不再变化的属性。\n例如， 用户的ID在一般情况下时不允许变化的。\n输出属性 (Output Properties):\n输出属性是ReactiveUI中新提出的概念，初次接触ReactiveUI时，可能会将输出属性与只读属性混为一谈。尽管输出属性对于用户而言是只读的，但是对于属性本身是可变的。这类属性通常由Observable变化而成，表示属性值可能随时间变化。 例如，用户负债率随用户的总资产和总负债变化，但负债率属性本身是不允许被用户修改的。\n在ReactiveUI中，使用这三种属性类型可以更清晰地表示属性的特性和用途。读写属性用于需要双向绑定的数据，只读属性用于一次性初始化后不再改变的数据，而输出属性用于表示可能随时间变化的数据流。这种划分有助于更好地理解和管理ViewModel中的属性。\n属性的声明与绑定方法 在明确了属性类型的基础上，ViewModel中所有非集合类型的属性都可以按照下面固定的方式进行声明与绑定。\n读写属性的声明需要调用ReactiveObject的RaiseAndSetIfChanged方法，该方法实现了INotifydPropertyChanged。\nprivate string name; public string Name { get =\u0026gt; name; set =\u0026gt; this.RaiseAndSetIfChanged(ref name, value); } 读写属性的绑定使用TView的Bind方法进行双向绑定。\nthis.WhenActivated(disposable =\u0026gt; { this.Bind(ViewModel, vm =\u0026gt; vm.Name, v =\u0026gt; v.NameTextBox.Text) .DisposeWith(disposable); }); 只读属性使用一般的声明方式即可。\npublic int Id {get;} 绑定时，使用单向绑定。\nthis.WhenActivated(disposable =\u0026gt; { this.OneWayBind(ViewModel, vm =\u0026gt; vm.Id, v =\u0026gt; v.IdTextBlock.Text) .DisposeWith(disposable); }); 输出属性也是使用固定的方式进行声明，但是在初始化时需要注意。\n// 声明 private readonly ObservableAsPropertyHelper\u0026lt;double\u0026gt; _debtAssetRatio; public string DebtAssetRatio =\u0026gt; _debtAssetRatio.Value; // WhenAnyValue产生一个Observable，当Debt或Asset变化时，会发出新的Debt/Asset的值。这里需要注意Debt和Asset必须也实现了INotifyPropertyChanged，否则无法观察到它们的变化。 // ToProperty将Observable转变为ObservableAsPropertyHelper。 UserAccountViewModel(){ this.WhenAnyValue(x =\u0026gt; x.Debt, x =\u0026gt; x.Asset, (debt, asset) =\u0026gt; debt/asset) .ToProperty(this, x =\u0026gt; x.DebtAssetRatio, out _debtAssetRatio); } 由于输出属性对用户而言也是只读的，所以使用单向绑定。\nthis.WhenActivated(disposable =\u0026gt; { this.OneWayBind(ViewModel, vm =\u0026gt; vm.DebtAssetRatio, v =\u0026gt; v.DebtAssetRatioTextBlock.Text) .DisposeWith(disposable); }); 集合 在使用集合类型的数据，最简单的情况是View中使用的是不可变的数据集合，例如显示Blog中已归档的文章列表，显示用户银行账户的历史交易信息等。这种情况下由于数据只在构造函数中被初始化，所以可以声明为任意集合类型，例如IEnmerable\u0026lt;T\u0026gt;、 IList\u0026lt;T\u0026gt;、ObservableCollection\u0026lt;T\u0026gt;。再在View中使用OneWayBind绑定。\n// ViewModel public IEnumerable\u0026lt;Article\u0026gt; Articles {get;} // View this.WhenActivated(disposable =\u0026gt; { this.OneWayBind(ViewModel, vm =\u0026gt; vm.Articles, v =\u0026gt; v.DataGrid.ItemsSource) .DisposeWith(disposable); }); 对于可变数据集合，则需要将集合声明为ObservableCollection\u0026lt;T\u0026gt;，然后在View中使用OneWayBind绑定。要注意的是T也需要实现INotifydPropertyChanged，否则T属性的变化无法触发View更新。\n到目前为止这和我们在以往使用WPF进行数据绑定时没有任何差异，那为什么还要将集合单拎出来特别说明。这是因为在ReactiveUI中推荐使用Dynamic Data来操作集合。ReactiveUI的文档中写的比较抽象，这里我将举例说明为什么使用Dynamic Data可以帮助我们更好的维护代码。\n在这个例子中，我将使用到两个DataGrid，其中SourceDataGrid中显示带有复选框的用户数据，SourceDataGrid中被选中的数据将被显示在OutputDataGrid中，也就是说OutputDataGrid是SourceDataGrid的一个视图。View的代码如下：\n// in MainWindow.xaml.xaml \u0026lt;Grid\u0026gt; \u0026lt;Grid.ColumnDefinitions\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;ColumnDefinition /\u0026gt; \u0026lt;/Grid.ColumnDefinitions\u0026gt; \u0026lt;Grid Margin=\u0026#34;0 0 4 0\u0026#34;\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;TextBlock Text=\u0026#34;Original DataGrid with Read-Write Items\u0026#34; /\u0026gt; \u0026lt;DataGrid Grid.Row=\u0026#34;1\u0026#34; x:Name=\u0026#34;SourceDataGrid\u0026#34; AutoGenerateColumns=\u0026#34;False\u0026#34;\u0026gt; \u0026lt;DataGrid.Columns\u0026gt; \u0026lt;DataGridCheckBoxColumn Binding=\u0026#34;{Binding IsSelected, UpdateSourceTrigger=PropertyChanged}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Id}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Name}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Age}\u0026#34; /\u0026gt; \u0026lt;/DataGrid.Columns\u0026gt; \u0026lt;/DataGrid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;Grid Grid.Column=\u0026#34;1\u0026#34; Margin=\u0026#34;4 0 0 0\u0026#34;\u0026gt; \u0026lt;Grid.RowDefinitions\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;Auto\u0026#34; /\u0026gt; \u0026lt;RowDefinition Height=\u0026#34;*\u0026#34; /\u0026gt; \u0026lt;/Grid.RowDefinitions\u0026gt; \u0026lt;TextBlock Text=\u0026#34;DataGrid Shows Output Properties that Filters IsSelected\u0026#34; /\u0026gt; \u0026lt;DataGrid Grid.Row=\u0026#34;1\u0026#34; x:Name=\u0026#34;OutputDataGrid\u0026#34; AutoGenerateColumns=\u0026#34;False\u0026#34;\u0026gt; \u0026lt;DataGrid.Columns\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Id}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Name}\u0026#34; /\u0026gt; \u0026lt;DataGridTextColumn Binding=\u0026#34;{Binding Age}\u0026#34; /\u0026gt; \u0026lt;/DataGrid.Columns\u0026gt; \u0026lt;/DataGrid\u0026gt; \u0026lt;/Grid\u0026gt; \u0026lt;/Grid\u0026gt; //in MainWindow.xaml.cs this.WhenActivated(disposable =\u0026gt; { this.OneWayBind(ViewModel, vm =\u0026gt; vm.ReadWriteItems, v =\u0026gt; v.SourceDataGrid.ItemsSource) .DisposeWith(disposable); this.OneWayBind(ViewModel, vm =\u0026gt; vm.OutputItems, v =\u0026gt; v.OutputDataGrid.ItemsSource) .DisposeWith(disposable); }); 在不使用Dynamic Data时，要使OutputItems在ReadWriteItems发生变化时同步刷新，可以选在在ReadWriteItems属性变化时，调用ReactiveObject的RaisePropertyChanged方法。但是，因为ObservableCollection只提供了CollectionChanged事件，这个事件只有当集合增删时会被触发，所以必须遍历ReadWriteItems的对象并在Item对象的PropertyChanged事件上增加处理方法。\npublic ObservableCollection\u0026lt;ItemViewModel\u0026gt; ReadWriteItems { get; } public IEnumerable\u0026lt;ItemViewModel\u0026gt; OutputItems =\u0026gt; ReadWriteItems.Where(x =\u0026gt; x.IsSelected); public MainWindowViewModel{ ReadWriteItems = new ObservableCollection\u0026lt;ItemViewModel\u0026gt;(ItemViewModel.GetItems()); foreach (var item in ReadWriteItems) item.PropertyChanged += (sender, args) =\u0026gt; { this.RaisePropertyChanged(nameof(OutputItems)); }; } 这种做法将业务逻辑分散在两个地方，表示筛选的部分放在了属性的声明中，而表示刷新的部分放在了构造函数中。当代码体量增加时，分散的代码会增加运维的成本。而使用Dynamic Data，可以将上述分散的代码合并在构造函数中。\nprivate readonly ReadOnlyObservableCollection\u0026lt;ItemViewModel\u0026gt; _outputItems; public ObservableCollection\u0026lt;ItemViewModel\u0026gt; ReadWriteItems { get; } public ReadOnlyObservableCollection\u0026lt;ItemViewModel\u0026gt; OutputItems =\u0026gt; _outputItems; public MainWindowViewModel{ ReadWriteItems = new ObservableCollection\u0026lt;ItemViewModel\u0026gt;(ItemViewModel.GetItems()); var disposable = ReadWriteItems.ToObservableChangeSet() .AutoRefresh() // .AutoRefreshOnObservable(x=\u0026gt;x.WhenPropertyChanged(i=\u0026gt;i.IsSelected)) .Filter(x=\u0026gt;x.IsSelected) .Bind(out _outputItems) .Subscribe(); } 在这段代码中，我们首先将ReadWriteItems转化为IObservable\u0026lt;IChangeSet\u0026lt;ItemViewModel\u0026gt;\u0026gt;，然后使用AutoRefresh将ReadWriteItems的变化向下传递，最终绑定到_outputItems中。在过程中我们调用Filter操作符对数据进行筛选，选出被选中的对象，还可以在后面串联更多的操作符对数据进行变换。需要注意结尾的Subscribe调用是不可缺少的，因为只有在被订阅后，上述操作才会生效。\n同样的原理，有时我们需要根据集合中数据的状态来切换按钮的状态，例如只有当全被选中时，才允许按钮被点击。\nprivate readonly ObservableAsPropertyHelper\u0026lt;bool\u0026gt; _isEnabled; public ObservableCollection\u0026lt;ItemViewModel\u0026gt; ReadWriteItems { get; } public bool IsEnabled =\u0026gt; _isEnabled.Value; public MainWindowViewModel{ ReadWriteItems = new ObservableCollection\u0026lt;ItemViewModel\u0026gt;(ItemViewModel.GetItems()); _isEnabled = ReadWriteItems.ToObservableChangeSet() .AutoRefresh() .ToCollection() .Select(x =\u0026gt; x.All(i =\u0026gt; i.IsSelected)) .ToProperty(this, x =\u0026gt; x.IsEnabled); } ","permalink":"http://localhost:1313/posts/reactiveui-viewmodel-properties%E6%80%BB%E7%BB%93/","summary":"\u003ch2 id=\"属性类型\"\u003e属性类型\u003c/h2\u003e\n\u003cp\u003e在ReactiveUI中，ViewModel中的属性可以根据其用途划分为三种情况：读写属性（Read-Write Properties）、只读属性（Read-Only Properties）和输出属性（Output Properties）。\u003c/p\u003e\n\u003cp\u003e读写属性 (Read-Write Properties):\u003c/p\u003e\n\u003cp\u003e读写属性是可以被服务修改，也可以被用户在View中修改的属性。这类属性是我们通常比较熟悉的普通属性。\u003c/p\u003e\n\u003cp\u003e例如，用户的姓名可能是被服务加载的，而在加载之后又被用户修改。\u003c/p\u003e\n\u003cp\u003e只读属性 (Read-Only Properties):\u003c/p\u003e\n\u003cp\u003e只读属性是在构造函数中被初始化且在之后不再变化的属性。\u003c/p\u003e\n\u003cp\u003e例如， 用户的ID在一般情况下时不允许变化的。\u003c/p\u003e\n\u003cp\u003e输出属性 (Output Properties):\u003c/p\u003e\n\u003cp\u003e输出属性是ReactiveUI中新提出的概念，初次接触ReactiveUI时，可能会将输出属性与只读属性混为一谈。尽管输出属性对于用户而言是只读的，但是对于属性本身是可变的。这类属性通常由Observable变化而成，表示属性值可能随时间变化。\n例如，用户负债率随用户的总资产和总负债变化，但负债率属性本身是不允许被用户修改的。\u003c/p\u003e\n\u003cp\u003e在ReactiveUI中，使用这三种属性类型可以更清晰地表示属性的特性和用途。读写属性用于需要双向绑定的数据，只读属性用于一次性初始化后不再改变的数据，而输出属性用于表示可能随时间变化的数据流。这种划分有助于更好地理解和管理ViewModel中的属性。\u003c/p\u003e\n\u003ch2 id=\"属性的声明与绑定方法\"\u003e属性的声明与绑定方法\u003c/h2\u003e\n\u003cp\u003e在明确了属性类型的基础上，ViewModel中所有\u003ccode\u003e非集合类型\u003c/code\u003e的属性都可以按照下面固定的方式进行声明与绑定。\u003c/p\u003e\n\u003cp\u003e读写属性的声明需要调用ReactiveObject的RaiseAndSetIfChanged方法，该方法实现了INotifydPropertyChanged。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eName\u003c/span\u003e \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eget\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eset\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRaiseAndSetIfChanged\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003eref\u003c/span\u003e \u003cspan class=\"n\"\u003ename\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003evalue\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e读写属性的绑定使用TView的Bind方法进行双向绑定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenActivated\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eBind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eName\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eNameTextBox\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eText\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDisposeWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e只读属性使用一般的声明方式即可。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003eint\u003c/span\u003e \u003cspan class=\"n\"\u003eId\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"k\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e绑定时，使用单向绑定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenActivated\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOneWayBind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eId\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eIdTextBlock\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eText\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDisposeWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e输出属性也是使用固定的方式进行声明，但是在初始化时需要注意。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// 声明\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003eprivate\u003c/span\u003e \u003cspan class=\"k\"\u003ereadonly\u003c/span\u003e \u003cspan class=\"n\"\u003eObservableAsPropertyHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_debtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003eDebtAssetRatio\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003e_debtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// WhenAnyValue产生一个Observable，当Debt或Asset变化时，会发出新的Debt/Asset的值。这里需要注意Debt和Asset必须也实现了INotifyPropertyChanged，否则无法观察到它们的变化。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// ToProperty将Observable转变为ObservableAsPropertyHelper。\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"n\"\u003eUserAccountViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e(){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenAnyValue\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDebt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAsset\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edebt\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003easset\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003edebt\u003c/span\u003e\u003cspan class=\"p\"\u003e/\u003c/span\u003e\u003cspan class=\"n\"\u003easset\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eToProperty\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDebtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"k\"\u003eout\u003c/span\u003e \u003cspan class=\"n\"\u003e_debtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e由于输出属性对用户而言也是只读的，所以使用单向绑定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenActivated\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOneWayBind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDebtAssetRatio\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDebtAssetRatioTextBlock\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eText\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDisposeWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003ch2 id=\"集合\"\u003e集合\u003c/h2\u003e\n\u003cp\u003e在使用集合类型的数据，最简单的情况是View中使用的是不可变的数据集合，例如显示Blog中已归档的文章列表，显示用户银行账户的历史交易信息等。这种情况下由于数据只在构造函数中被初始化，所以可以声明为任意集合类型，例如\u003ccode\u003eIEnmerable\u0026lt;T\u0026gt;\u003c/code\u003e、 \u003ccode\u003eIList\u0026lt;T\u0026gt;\u003c/code\u003e、\u003ccode\u003eObservableCollection\u0026lt;T\u0026gt;\u003c/code\u003e。再在View中使用OneWayBind绑定。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// ViewModel\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eIEnumerable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eArticle\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eArticles\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"k\"\u003eget\u003c/span\u003e\u003cspan class=\"p\"\u003e;}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e// View\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eWhenActivated\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ethis\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOneWayBind\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eViewModel\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003evm\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eArticles\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ev\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDataGrid\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eItemsSource\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDisposeWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edisposable\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e});\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e对于可变数据集合，则需要将集合声明为\u003ccode\u003eObservableCollection\u0026lt;T\u0026gt;\u003c/code\u003e，然后在View中使用OneWayBind绑定。要注意的是\u003ccode\u003eT\u003c/code\u003e也需要实现\u003ccode\u003eINotifydPropertyChanged\u003c/code\u003e，否则T属性的变化无法触发View更新。\u003c/p\u003e","title":"ReactiveUI ViewModel Properties总结"},{"content":"当使用Visual Studio Installer进行打包时，要实现安装时自动卸载旧版本然后安装新版本，需要同时设置以下各点：\nDeployment Project Properties -\u0026gt; DetectNewerInstalledVersion -\u0026gt; True Deployment Project Properties -\u0026gt; RemovePreviousVersions -\u0026gt; True Deployment Project Properties -\u0026gt; Version 其中，Version被安装程序用来判断是否继续执行安装程序，所以Version值应大于上一个版本。\n满足以上条件时，执行安装程序可以顺利执行，且控制面板中可以看到更新后的版本号。但是，安装程序仍然可能没有正确执行。这是因为项目的主输出并没有被正确拷贝。这往往是因为没有正确设置项目（程序项目，非部署项目）的AssemblyInfo。主输出中的Version将被用来比较是否需要拷贝主输出到安装目录，所以当上一版本的主输出版本为0.2.1.0时，即使已经设置部署项目的Version为0.2.2.0，由于此时主输出的版本仍然为0.2.1.0，安装过程中不会拷贝新生成的主输出到安装目录。\n主输出的Version设置位于程序项目的AssemblyInfo.cs文件中。只有当此文件中的AssemblyVersion或AssemblyFileVersion的值大于上一个版本的值时，才会覆盖原安装目录的dll。\n","permalink":"http://localhost:1313/posts/visual-studio-installer%E5%AE%9E%E7%8E%B0%E8%A6%86%E7%9B%96%E5%AE%89%E8%A3%85%E6%96%B0%E7%89%88%E6%9C%AC%E7%9A%84%E6%96%B9%E6%B3%95/","summary":"\u003cp\u003e当使用Visual Studio Installer进行打包时，要实现安装时自动卸载旧版本然后安装新版本，需要同时设置以下各点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDeployment Project Properties -\u0026gt; DetectNewerInstalledVersion -\u0026gt; True\u003c/li\u003e\n\u003cli\u003eDeployment Project Properties -\u0026gt; RemovePreviousVersions -\u0026gt; True\u003c/li\u003e\n\u003cli\u003eDeployment Project Properties -\u0026gt; Version\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"deployment-project-properties.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/28/5ToctnJNzqDbaks.png\"\u003e\u003c/p\u003e\n\u003cp\u003e其中，Version被安装程序用来判断是否继续执行安装程序，所以Version值应大于上一个版本。\u003c/p\u003e\n\u003cp\u003e满足以上条件时，执行安装程序可以顺利执行，且控制面板中可以看到更新后的版本号。但是，安装程序仍然可能没有正确执行。这是因为项目的主输出并没有被正确拷贝。这往往是因为没有正确设置项目（程序项目，非部署项目）的AssemblyInfo。主输出中的Version将被用来比较是否需要拷贝主输出到安装目录，所以当上一版本的主输出版本为0.2.1.0时，即使已经设置部署项目的Version为0.2.2.0，由于此时主输出的版本仍然为0.2.1.0，安装过程中不会拷贝新生成的主输出到安装目录。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"assembly-info.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/28/BipWZAytP5qGQrl.png\"\u003e\u003c/p\u003e\n\u003cp\u003e主输出的Version设置位于程序项目的AssemblyInfo.cs文件中。只有当此文件中的AssemblyVersion或AssemblyFileVersion的值大于上一个版本的值时，才会覆盖原安装目录的dll。\u003c/p\u003e","title":"Visual Studio Installer实现覆盖安装新版本的方法"},{"content":"在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。\n尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。\n本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。\n拖拽背后的故事 当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。） 当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。\n这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。\n手动更新 要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。\n使用COM批量更新 借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。\n要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：\npublic IEnumerable\u0026lt;IVShape\u0026gt; GetInstances(IVMaster master) { var instances = document.Pages.OfType\u0026lt;IVPage\u0026gt;() .SelectMany(x =\u0026gt; x.Shapes.OfType\u0026lt;IVShape\u0026gt;()).Where(x =\u0026gt; x.Master == master).ToList(); return instances; } 要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。\n关键代码：\npublic IVMaster GetLatestMaster(IVDocument document, string baseID) { var latestMaster = document.Masters.OfType\u0026lt;IVMaster\u0026gt;() .SingleOrDefault(x =\u0026gt; x.BaseID == baseID); return latestMaster; } 然后，遍历这些事例，并将形状替换为新版本的模具。\npublic void Replace(IEnumerable\u0026lt;IVShape\u0026gt; instances, IVMaster latestMaster) { foreach (var instance in instances) { instance.ReplaceShape(latestMaster); } } 使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。\n另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。\n使用OpenXML批量更新 当不要求在原文件中完成更新时，可以考虑直接修改OpenXML文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为\u0026quot;.vsdx\u0026quot;。要查看OpenXML格式的详细内容，可以修改文档后缀为\u0026quot;.zip\u0026quot;后打开压缩包。\n.\\visio\\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。\n其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考以编程方式处理Visio文件格式):\npublic IEnumerable\u0026lt;XlElement\u0026gt; GetMasterElements(Package package) { // mastersPart指masters.xml var mastersPart = package.GetPart(XmlHelper.MastersPartUri); // 筛选出BaseID属性为baseID的Master节点 var masterElements = XmlHelper.GetXElementsByName(mastersPart, \u0026#34;Master\u0026#34;). return masterElements; } public PackagePart GetMasterContentsFile(Package package, string baseID){ var masterElement = GetMasterElement(package).SingleOrDefault(x=\u0026gt;x.Attribute(\u0026#34;BaseID\u0026#34;)!.Value == baseID); // 通过子节点Rel获取r:id var relElement = masterElement.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First(); var relId = relElement.Attribute(XmlHelper.RelNs + \u0026#34;id\u0026#34;)!.Value; var rel = mastersPart.GetRelationship(relId); // masterPart指master{i}.xml var masterPart = package.GetPart(PackUriHelper.ResolvePartUri(rel.SourceUri, rel.TargetUri)); return masterPart; } 当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：\npublic void Replace(Package drawingDoc, Package stencilDoc, string baseID){ var mastersPartDrawing = sourcePackage.GetPart(XmlHelper.MastersPartUri); foreach (var masterEleDrawing in GetMasterElements(drawingDoc)) { // 查看模具库中是否存在对应的Master var masterEleStencil = GetMasterElements(stencilDoc).SingleOrDefault(x=\u0026gt;x.Attribute(\u0026#34;BaseID\u0026#34;)!.Value == baseID); if (masterEleStencil == null) continue; // 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点 var relEleDrawing = masterEleDrawing.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First(); masterEleStencil.Descendants(XmlHelper.MainNs + \u0026#34;Rel\u0026#34;).First().ReplaceWith(relEleDrawing); masterEleDrawing.ReplaceWith(masterEleStencil); // 替换MasterContents var contentsPartDrawing = GetMasterContentsFile(drawingDoc, baseID); var contentsPartStencil = GetMasterContentsFile(stencilDoc, baseID); XmlHelper.SaveXDocumentToPart(contentsPartDrawing, XmlHelper.GetXmlFromPart(contentsPartStencil)); } XmlHelper.RecalculateDocument(drawingDoc); XmlHelper.SaveXDocumentToPart(mastersPartDrawing, XmlHelper.GetXmlFromPart(mastersPartDrawing)); } 查看完整代码\n","permalink":"http://localhost:1313/posts/%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0visio%E6%96%87%E6%A1%A3%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%85%B7/","summary":"\u003cp\u003e在工程设计领域，流程图设计是许多企业不可或缺的一环。Visio，作为备受推崇的流程图设计工具，正在成为越来越多企业的首选，以期通过规范化的流程设计来提升整体工作效率。\u003c/p\u003e\n\u003cp\u003e尽管Visio提供了丰富的内置模具库，但在实际应用中，通用模具往往难以满足企业独特的业务需求。为了更好地适应企业的特殊流程和标准，许多企业纷纷转向定制模具库的方向，这与我们从外企的学习中所观察到的趋势是一致的。然而，由于缺乏指导性的方法，企业在推广和运用Visio时可能会面临一系列挑战。其中一个普遍存在的问题是在初版模具库建立后，如何有效地进行迭代更新。\u003c/p\u003e\n\u003cp\u003e本文将讨论Visio文档中模具更新的实现。首先介绍用户从模具库拖拽至绘图页时的背后过程，揭示为什么文档中的形状实例不会随模具库的更新而更新。随后介绍手动更新的方法。最后，提供比较两种自动化更新的方法及实现刚方法模具需满足的条件。\u003c/p\u003e\n\u003ch2 id=\"拖拽背后的故事\"\u003e拖拽背后的故事\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://techcommunity.microsoft.com/t5/microsoft-365-blog/drag-drop-done/ba-p/237244\"\u003e当用户首次从模具库拖拽模具到绘图页（Page）时，Visio在后台完成了多个操作\u003c/a\u003e。首先，Visio会在文档的文档模具（Document Stencil）中创建该模具的副本，然后再在绘图页上创建针对该模具形状的实例。由于文档模具默认是隐藏的，所以用户可能无法察觉到这一点。（要显示文档模具，首先需要在“选项”-“自定义功能区”中启用“开发者”选项卡。然后，在“开发者”选项卡-“显示/隐藏”分组中勾选“文档模具”。）\n当用户再一次从模具库拖拽同一个模具时，Visio将检查文档模具中是否已存在该模具的副本。如果副本已经存在，Visio将直接创建实例。那么Visio是如何判断模具已存在的？在默认情况下Visio会比较模具的UniqueID属性。因此，即使两个模具具有相同的名称，Visio也可以通过UniqueID判断它们的对应关系。每当用户编辑并保存模具时，模具的UniqueID会发生变化。所以拖拽修改后的模具到绘图页时，可以观察到文档模具中出现了新的副本。这也就是为什么修改了模具库中的模具，绘图页中的实例没有被更新。\u003c/p\u003e\n\u003cp\u003e这显然与我们的期望不符。我们希望图纸中的实例永远与最新的模具一致。\u003c/p\u003e\n\u003ch2 id=\"手动更新\"\u003e手动更新\u003c/h2\u003e\n\u003cp\u003e要将实例引用的模具修改为最新的模具，一种已知的方法是使用“主页”-“更改形状”对图纸中的实例进行更改。但是，对于已包含大量实例的文档，这个操作费时费力。尤其是当新版模具与旧模具的差异并不大时，用户很容易发生遗漏。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"change-shape.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/26/YSPq96nDTp2vEib.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"使用com批量更新\"\u003e使用COM批量更新\u003c/h2\u003e\n\u003cp\u003e借助COM组件，我们可以通过创建自动化程序的方式批量选择某一模具的实例，然后调用Shape.ReplaceShape()方法，实现批量更改这些实例的形状。\u003c/p\u003e\n\u003cp\u003e要获取文档模具中模具在文档中的所有实例，我们可以调用遍历文档中的所有形状，并筛选出Shape.Master等于文档模具中的Master情况。关键代码如下：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eIEnumerable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVShape\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eGetInstances\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eIVMaster\u003c/span\u003e \u003cspan class=\"n\"\u003emaster\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003einstances\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003ePages\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOfType\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVPage\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSelectMany\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eShapes\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOfType\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVShape\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;()).\u003c/span\u003e\u003cspan class=\"n\"\u003eWhere\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMaster\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003emaster\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eToList\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003einstances\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e要找出模具库中对应的新模具，需要使用到模具的另一个ID属性————BaseID。模具的BaseID是在模具被创建的时候生成的，随后不会发生改变。因此，可以通过BaseID找到模具库中的同源模具。但是，使用这种方式时，要求模具库中的BaseID具有唯一性。一种常见的错误是管理员在创建模具时，采用的不是首先在绘图页绘制模具形状再拖拽至模具库，而是直接将模具库中的模具复制成了新的模具并编辑该模具。此时，模具库中的代表不通类型的模具具有相同的BaseID。\u003c/p\u003e\n\u003cp\u003e关键代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eIVMaster\u003c/span\u003e \u003cspan class=\"n\"\u003eGetLatestMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eIVDocument\u003c/span\u003e \u003cspan class=\"n\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003elatestMaster\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003edocument\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMasters\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eOfType\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;()\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSingleOrDefault\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eBaseID\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003elatestMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e然后，遍历这些事例，并将形状替换为新版本的模具。\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eReplace\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eIEnumerable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eIVShape\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003einstances\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eIVMaster\u003c/span\u003e \u003cspan class=\"n\"\u003elatestMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eforeach\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003einstance\u003c/span\u003e \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003einstances\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003einstance\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eReplaceShape\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003elatestMaster\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e使用COM方式更新的好处是可以直接在原文件中进行修改。然而，由于UI的频繁更新可能导致方法执行时间较长，特别是在复杂的涂装车间原理图中，可能需要数分钟。因此，为了提升用户的使用体验，开发者可能会考虑加入进度条，以直观地显示更新进度。但是Visio使用STA模型且UI更新过程会向主线程封送消息，如果使用WPF组件，UI线程会发生阻塞，因此应使用WinForm。\u003c/p\u003e\n\u003cp\u003e另一个不利因素是，更新可能会引发连接线（Connector）的几何属性重新计算。也就是说，直角型连接线的折点位置可能会发生改变。\u003c/p\u003e\n\u003ch2 id=\"使用openxml批量更新\"\u003e使用OpenXML批量更新\u003c/h2\u003e\n\u003cp\u003e当不要求在原文件中完成更新时，可以考虑直接修改\u003ca href=\"https://learn.microsoft.com/en-us/office/client-developer/visio/introduction-to-the-visio-file-formatvsdx\"\u003eOpenXML\u003c/a\u003e文件。OpenXML是一种基于XML的文件格式，在2013年被引入Visio。OpenXML格式的Visio文档后缀为\u0026quot;.vsdx\u0026quot;。要查看OpenXML格式的详细内容，可以修改文档后缀为\u0026quot;.zip\u0026quot;后打开压缩包。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"open-vsdx-as-zip.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/26/1dKCDJwfYpV6B79.png\"\u003e\u003c/p\u003e\n\u003cp\u003e.\\visio\\masters目录下存储了文档模具的相关内容。masters.xml文件中列出了文档模具中的模具的部分属性。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"master.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/26/BLtjEZDhK4a3crA.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"master-content.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/12/26/38Wx795LYotHfdk.png\"\u003e\u003c/p\u003e\n\u003cp\u003e其中，对我们有用的是Master节点的BaseID属性和Rel子节点的r:id属性。前者的作用已在前文中提及。r:id属性可以通过查看_rels文件夹下的masters.xml.rels确定与此Master关联的MasterContents文件。MasterContents文件定义了模具的形状。关键代码（XmlHelper部分的代码参考\u003ca href=\"https://learn.microsoft.com/en-us/office/client-developer/visio/how-to-manipulate-the-visio-file-format-programmatically\"\u003e以编程方式处理Visio文件格式\u003c/a\u003e):\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003eIEnumerable\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"n\"\u003eXlElement\u003c/span\u003e\u003cspan class=\"p\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterElements\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePackage\u003c/span\u003e \u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// mastersPart指masters.xml\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emastersPart\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMastersPartUri\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 筛选出BaseID属性为baseID的Master节点\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterElements\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetXElementsByName\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emastersPart\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Master\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003emasterElements\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"n\"\u003ePackagePart\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterContentsFile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePackage\u003c/span\u003e \u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterElement\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterElement\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eSingleOrDefault\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAttribute\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;BaseID\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)!.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// 通过子节点Rel获取r:id\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003erelElement\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emasterElement\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDescendants\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMainNs\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Rel\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eFirst\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003erelId\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003erelElement\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAttribute\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRelNs\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;id\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)!.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003erel\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emastersPart\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetRelationship\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erelId\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"c1\"\u003e// masterPart指master{i}.xml\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterPart\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003epackage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePackUriHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eResolvePartUri\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erel\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSourceUri\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003erel\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eTargetUri\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003ereturn\u003c/span\u003e \u003cspan class=\"n\"\u003emasterPart\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e当我们更新文档中的模具时，实际上只需要将Master节点和MasterContents节点替换为修改后的模具库中的对应内容。关键代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-C#\" data-lang=\"C#\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kd\"\u003epublic\u003c/span\u003e \u003cspan class=\"k\"\u003evoid\u003c/span\u003e \u003cspan class=\"n\"\u003eReplace\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ePackage\u003c/span\u003e \u003cspan class=\"n\"\u003edrawingDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ePackage\u003c/span\u003e \u003cspan class=\"n\"\u003estencilDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"kt\"\u003estring\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e){\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emastersPartDrawing\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003esourcePackage\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMastersPartUri\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"k\"\u003eforeach\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterEleDrawing\u003c/span\u003e \u003cspan class=\"k\"\u003ein\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterElements\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edrawingDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e))\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 查看模具库中是否存在对应的Master\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003emasterEleStencil\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterElements\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estencilDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eSingleOrDefault\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e=\u0026gt;\u003c/span\u003e\u003cspan class=\"n\"\u003ex\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eAttribute\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;BaseID\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e)!.\u003c/span\u003e\u003cspan class=\"n\"\u003eValue\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"k\"\u003eif\u003c/span\u003e \u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emasterEleStencil\u003c/span\u003e \u003cspan class=\"p\"\u003e==\u003c/span\u003e \u003cspan class=\"kc\"\u003enull\u003c/span\u003e\u003cspan class=\"p\"\u003e)\u003c/span\u003e \u003cspan class=\"k\"\u003econtinue\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 使用模具库中的Master节点替换文档中的Master节点。但是由于模具库中的Rel关系和可能与文档中的不一致，所以为了不去修改masters.xml.rel文件，仍使用原文档中的Rel节点\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003erelEleDrawing\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003emasterEleDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDescendants\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMainNs\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Rel\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eFirst\u003c/span\u003e\u003cspan class=\"p\"\u003e();\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003emasterEleStencil\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eDescendants\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eMainNs\u003c/span\u003e \u003cspan class=\"p\"\u003e+\u003c/span\u003e \u003cspan class=\"s\"\u003e\u0026#34;Rel\u0026#34;\u003c/span\u003e\u003cspan class=\"p\"\u003e).\u003c/span\u003e\u003cspan class=\"n\"\u003eFirst\u003c/span\u003e\u003cspan class=\"p\"\u003e().\u003c/span\u003e\u003cspan class=\"n\"\u003eReplaceWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003erelEleDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003emasterEleDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eReplaceWith\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emasterEleStencil\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"c1\"\u003e// 替换MasterContents\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003econtentsPartDrawing\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterContentsFile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edrawingDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"kt\"\u003evar\u003c/span\u003e \u003cspan class=\"n\"\u003econtentsPartStencil\u003c/span\u003e \u003cspan class=\"p\"\u003e=\u003c/span\u003e \u003cspan class=\"n\"\u003eGetMasterContentsFile\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003estencilDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003ebaseID\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e        \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSaveXDocumentToPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtentsPartDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetXmlFromPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003econtentsPartStencil\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eRecalculateDocument\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003edrawingDoc\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eSaveXDocumentToPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emastersPartDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e \u003cspan class=\"n\"\u003eXmlHelper\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"n\"\u003eGetXmlFromPart\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"n\"\u003emastersPartDrawing\u003c/span\u003e\u003cspan class=\"p\"\u003e));\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003ca href=\"https://github.com/Snailya/AE.PID/blob/main/PID.VisioAddIn/Controllers/Services/DocumentUpdater.cs\"\u003e查看完整代码\u003c/a\u003e\u003c/p\u003e","title":"如何更新Visio文档中的模具"},{"content":"很不幸，又遇到了同样的问题。但这次问题涉及到一个容器对象，该容器内的某个形状链接了容器的某个属性值。当使用Shape.Replace()方法进行更新时，该属性又被更新成“OBJ”。\n因此，按照之前提到的方法，我们首先删除了我们自定义的容器的基本属性，例如SelectMode、DisplayMode、CalWH等。然后重新执行更新程序。此时，“OBJ”被正确的属性值所取代。\n通过Visio应用程序的编辑模具功能，重新定义先前的基本属性，再次执行更新程序。不幸的是OBJ又出现了。\n最终我们发现，当同时满足以下两个条件时，会产生上述的BUG：\nIsTextEditTarget=False GlueType=8 ","permalink":"http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E4%BD%BF%E7%94%A8shape-replace%E6%96%B9%E6%B3%95%E6%98%BE%E7%A4%BAobj%E7%9A%84bug-2/","summary":"\u003cp\u003e很不幸，又遇到了同样的问题。但这次问题涉及到一个容器对象，该容器内的某个形状链接了容器的某个属性值。当使用Shape.Replace()方法进行更新时，该属性又被更新成“OBJ”。\u003c/p\u003e\n\u003cp\u003e因此，按照之前提到的方法，我们首先删除了我们自定义的容器的基本属性，例如SelectMode、DisplayMode、CalWH等。然后重新执行更新程序。此时，“OBJ”被正确的属性值所取代。\u003c/p\u003e\n\u003cp\u003e通过Visio应用程序的编辑模具功能，重新定义先前的基本属性，再次执行更新程序。不幸的是OBJ又出现了。\u003c/p\u003e\n\u003cp\u003e最终我们发现，当同时满足以下两个条件时，会产生上述的BUG：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eIsTextEditTarget=False\u003c/li\u003e\n\u003cli\u003eGlueType=8\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/11/W17f94tyPncGdTC.png\"\u003e\n\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/10/13/dq1KO5MIRJYrBDs.png\"\u003e\u003c/p\u003e","title":"解决Visio使用Shape Replace方法显示OBJ的BUG 2"},{"content":"引言 许多Visio管理员在项目初期都会面临模具频繁更新的问题。由于Visio的机制，每当用户首次从模具库中拖拽模具至绘图页时，实际上是从该模具库中拷贝了模具的副本至文档模具中。这种机制无疑切断了文档模具与原模具库的联系，也造成管理更新模具库后无法将更新应用到已有的绘图上。当绘图上需要更新的形状数量较少时，可以使用Visio提供的更改形状功能手动更新。但是，当绘图页中存在大量的待更新形状时，使用使用程序进行批量更新。\n程序批量更新的方法是遍历文档模具，并通过文档模具中模具的BaseID从模具库中找到源模具，再比较两者的UniqueID是否一致。若UniqueID一致，说明该模具没有更新，应跳过操作；若不一致，说明源模具发生了更新。然后在绘图页中找到所有与该模具关联的形状，然后删除文档模具中的旧模具，再执行Shape.Replace()方法使用新的模具替换形状。\n这种方法通常是凑效的，但是在上一周中，我遇到了如下的BUG：更新后的形状显示Obj文本。仔细查看形状shapesheet，可以发现模具中已经定义好的TextField在形状中变成了空白，造成显示错误。\n不幸的是，未能在Google中搜到类似的问题反馈。\n问题排查 通过查看xml文件，发现该形状的Field节被替换为了\u0026lt;Row IX='0' Del='1'/\u0026gt;。对比未出现显示错误的形状的xml文件可以发现：当TextField取值为空时，Field节应该继承自模具，因此xml文档不应出现Field节；当TextField存在取值时，Row节点内应该有Cell节点。此时，如果手动删除Field节，显示的OBJ文字消失。由此可以推出Field节数据发生了异常。\n但是，仍然无法确定该异常的产生是因为形状定义错误还是其他。\n回到Visio应用程序中，在源模具中的形状树中删除发生该问题的子形状，再次执行更新程序，原本没有问题的子形状的TextField出现同样的问题。重复执行删除子形状并更新的操作，问题始终出现。当所有的子形状都被删除后，更新后的形状不再显示OBJ。但是，新的问题出现了：形状显示数字3。显然我们并没有在模具的任何形状或子形状中定义过这个数值。\n由此可以推出，形状定义并没有问题，而是其他数据导致了Visio更新时的异常行为。\n为了确定是哪一部分数据存在问题，我们清空了User、ShapeData等全部用于定义用户数据的Section，问题依然复现。现在，只剩模具的基础数据了（诸如PinX、PinY等Shape节点下的Cell节点）。由于Visio中不能删除基础数据，所以在XML文件中用其他正常模具的基础数据替换问题模具的基础数据。此后，再使用程序对绘图页的形状进行更新，数字3不再出现，也就是这个BUG被修复了。\n通过文本对比工具，我们比较了问题模具与正常模具的基础数据。\n（此处，因为重启电脑图丢了。。。。。）\n比较两者的基础数据并没有特别的地方，除了尺寸和定位存在数值差异外，只有Cell的顺序存在区别。最终也无法确定这个问题到底是怎么产生的。\n解决方法 尽管未能找到该问题形成的原因，但通过定位问题位置，我们找到了解决该问题的方法：即使用正常模具的基础数据覆盖问题模具。\n","permalink":"http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E4%BD%BF%E7%94%A8shape-replace%E6%96%B9%E6%B3%95%E6%98%BE%E7%A4%BAobj%E7%9A%84bug/","summary":"\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cp\u003e许多Visio管理员在项目初期都会面临模具频繁更新的问题。由于Visio的机制，每当用户首次从模具库中拖拽模具至绘图页时，实际上是从该模具库中拷贝了模具的副本至文档模具中。这种机制无疑切断了文档模具与原模具库的联系，也造成管理更新模具库后无法将更新应用到已有的绘图上。当绘图上需要更新的形状数量较少时，可以使用Visio提供的更改形状功能手动更新。但是，当绘图页中存在大量的待更新形状时，使用使用程序进行批量更新。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"image.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/09/26/oXsOTbSZ73U4wyV.png\"\u003e\u003c/p\u003e\n\u003cp\u003e程序批量更新的方法是遍历文档模具，并通过文档模具中模具的BaseID从模具库中找到源模具，再比较两者的UniqueID是否一致。若UniqueID一致，说明该模具没有更新，应跳过操作；若不一致，说明源模具发生了更新。然后在绘图页中找到所有与该模具关联的形状，然后删除文档模具中的旧模具，再执行Shape.Replace()方法使用新的模具替换形状。\u003c/p\u003e\n\u003cp\u003e这种方法通常是凑效的，但是在上一周中，我遇到了如下的BUG：更新后的形状显示Obj文本。仔细查看形状shapesheet，可以发现模具中已经定义好的TextField在形状中变成了空白，造成显示错误。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"企业微信截图_16947712887795.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/09/26/IDtNBP16GOdfxu4.png\"\u003e\u003c/p\u003e\n\u003cp\u003e不幸的是，未能在Google中搜到类似的问题反馈。\u003c/p\u003e\n\u003ch2 id=\"问题排查\"\u003e问题排查\u003c/h2\u003e\n\u003cp\u003e通过查看xml文件，发现该形状的Field节被替换为了\u003ccode\u003e\u0026lt;Row IX='0' Del='1'/\u0026gt;\u003c/code\u003e。对比未出现显示错误的形状的xml文件可以发现：当TextField取值为空时，Field节应该继承自模具，因此xml文档不应出现Field节；当TextField存在取值时，Row节点内应该有Cell节点。此时，如果手动删除Field节，显示的OBJ文字消失。由此可以推出Field节数据发生了异常。\u003c/p\u003e\n\u003cp\u003e但是，仍然无法确定该异常的产生是因为形状定义错误还是其他。\u003c/p\u003e\n\u003cp\u003e回到Visio应用程序中，在源模具中的形状树中删除发生该问题的子形状，再次执行更新程序，原本没有问题的子形状的TextField出现同样的问题。重复执行删除子形状并更新的操作，问题始终出现。当所有的子形状都被删除后，更新后的形状不再显示OBJ。但是，新的问题出现了：形状显示数字3。显然我们并没有在模具的任何形状或子形状中定义过这个数值。\u003c/p\u003e\n\u003cp\u003e由此可以推出，形状定义并没有问题，而是其他数据导致了Visio更新时的异常行为。\u003c/p\u003e\n\u003cp\u003e为了确定是哪一部分数据存在问题，我们清空了User、ShapeData等全部用于定义用户数据的Section，问题依然复现。现在，只剩模具的基础数据了（诸如PinX、PinY等Shape节点下的Cell节点）。由于Visio中不能删除基础数据，所以在XML文件中用其他正常模具的基础数据替换问题模具的基础数据。此后，再使用程序对绘图页的形状进行更新，数字3不再出现，也就是这个BUG被修复了。\u003c/p\u003e\n\u003cp\u003e通过文本对比工具，我们比较了问题模具与正常模具的基础数据。\u003c/p\u003e\n\u003cp\u003e（此处，因为重启电脑图丢了。。。。。）\u003c/p\u003e\n\u003cp\u003e比较两者的基础数据并没有特别的地方，除了尺寸和定位存在数值差异外，只有Cell的顺序存在区别。最终也无法确定这个问题到底是怎么产生的。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e尽管未能找到该问题形成的原因，但通过定位问题位置，我们找到了解决该问题的方法：即使用正常模具的基础数据覆盖问题模具。\u003c/p\u003e","title":"解决Visio使用Shape Replace方法显示OBJ的BUG"},{"content":"引言 在 Visio 中，可以通过使用外部数据来创建和更新图标、图形和其它可视化元素。例如，可以通过外部数据绑定，建立形状与数据表之间的同步关系，实现当外部数据发生变化时，Visio 图形的自动更新。利用这个方法，既可以解决人工通过 Excel 批量修改形状数据的需求，又可以实现数据库自动更新数据的需求。\n但是，目前针对外部数据功能的教程非常少，均是以组织架构图或时序图为例，以人工拖拽的方式实现数据链接到形状，鲜有如何自动将导入的数据连接到形状的教程。尽管 Microsoft 官方提供了自动链接向导将导入的数据连接到形状的支持文档，但是仅参照该文档并不能实现我们如下的需求：\n通过数据导出功能导出形状的数据至 Excel 表格 通过数据导入及自动链接功能将修改后的 Excel 表格与 Visio 形状数据的自动绑定，实现形状数据的更新。 该需求应于我们的业务过程存在的批量修改某类设备型号、供应商的情况。面对大量的设备，如果通过 Visio 逐次去修改每个形状的数据，一是操作繁琐耗时，二是容易产生遗漏，以上两个问题均可以得到解决。\n问题描述 借助数据库导出向导，我们可以将指定图层上的形状数据导出至数据库（或 Excel 文档），导出过程中将使用形状的 ID 作为数据表的 Key。因此，在将数据表导回 Visio 时，只需将 Key 值与形状的 ID 关联，理论上应该可以实现自动将数据链接至形状。\n但是，在实际操作中，外部数据窗口中并没有出现链接符号，即绑定失败了。\n此时，如果使用拖拽的方式将数据连接至形状，还会发现 Visio 并没有如期更新已有的属性，而是将表格中的属性作为新的属性写入形状。\n也就是说，要实现我们的需求需要解决如下两个问题：\n自动链接数据至形状数据 更新已有形状数据而不是新建数据 原因分析 针对问题一，使用录制宏功能，可以发现当设置形状的 ObjectID 与数据源中的 ShapeKey 匹配时，没有录制上任何有效代码，而其它选项均有代码被录制。因此推测 ID(Object Info)不是有效选项。\n针对问题二，由于在导出数据时，允许重新定义属性的名称，因此推测属性名称在更新数据时起关联作用，即表格中的列名称应与属性的 Name 或 Label 一致。经过多次尝试，应设置列名称为属性的 Label。\n解决方法 因此，要在 Visio 中实现外部数据绑定与自动更新，需要完成以下操作:\n在 User Section 中添加新的 ShapeID 属性，并设置其公式为\u0026quot;=GUARD(ID())\u0026quot;。 在数据导出窗口中，依次修改导出属性的 Field Name 为其 Label。 在自动链接窗口中，选择 Shape Field 的值为 User.ShapeID. 此时，修改后的数据已与形状自动关联。\n","permalink":"http://localhost:1313/posts/%E8%A7%A3%E5%86%B3visio%E5%A4%96%E9%83%A8%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%A4%B1%E8%B4%A5%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BD%A2%E7%8A%B6id%E5%B1%9E%E6%80%A7/","summary":"\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cp\u003e在 Visio 中，可以通过使用外部数据来创建和更新图标、图形和其它可视化元素。例如，可以通过外部数据绑定，建立形状与数据表之间的同步关系，实现当外部数据发生变化时，Visio 图形的自动更新。利用这个方法，既可以解决人工通过 Excel 批量修改形状数据的需求，又可以实现数据库自动更新数据的需求。\u003c/p\u003e\n\u003cp\u003e但是，目前针对外部数据功能的教程非常少，均是以组织架构图或时序图为例，以人工拖拽的方式实现数据链接到形状，鲜有如何自动将导入的数据连接到形状的教程。尽管 Microsoft 官方提供了\u003ca href=\"https://support.microsoft.com/zh-cn/office/%E8%87%AA%E5%8A%A8%E5%B0%86%E5%AF%BC%E5%85%A5%E7%9A%84%E6%95%B0%E6%8D%AE%E9%93%BE%E6%8E%A5%E5%88%B0%E5%BD%A2%E7%8A%B6-be56f5ff-9b13-4311-9a6c-b27dd243dbea\"\u003e自动链接向导将导入的数据连接到形状\u003c/a\u003e的支持文档，但是仅参照该文档并不能实现我们如下的需求：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e通过数据导出功能导出形状的数据至 Excel 表格\u003c/li\u003e\n\u003cli\u003e通过数据导入及自动链接功能将修改后的 Excel 表格与 Visio 形状数据的自动绑定，实现形状数据的更新。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e该需求应于我们的业务过程存在的批量修改某类设备型号、供应商的情况。面对大量的设备，如果通过 Visio 逐次去修改每个形状的数据，一是操作繁琐耗时，二是容易产生遗漏，以上两个问题均可以得到解决。\u003c/p\u003e\n\u003ch2 id=\"问题描述\"\u003e问题描述\u003c/h2\u003e\n\u003cp\u003e借助数据库导出向导，我们可以将指定图层上的形状数据导出至数据库（或 Excel 文档），导出过程中将使用形状的 ID 作为数据表的 Key。因此，在将数据表导回 Visio 时，只需将 Key 值与形状的 ID 关联，理论上应该可以实现自动将数据链接至形状。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"key-field.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/KcMqIOdNn2SVwLi.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"link-to-object-id.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/FguYD1bfpV2OBlo.png\"\u003e\u003c/p\u003e\n\u003cp\u003e但是，在实际操作中，外部数据窗口中并没有出现链接符号，即绑定失败了。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"failed-on-linking-shape-id.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/lC1HozFsIpYK5rw.png\"\u003e\u003c/p\u003e\n\u003cp\u003e此时，如果使用拖拽的方式将数据连接至形状，还会发现 Visio 并没有如期更新已有的属性，而是将表格中的属性作为新的属性写入形状。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"auto-create-properties.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/gz3oXulY4riAytB.png\"\u003e\u003c/p\u003e\n\u003cp\u003e也就是说，要实现我们的需求需要解决如下两个问题：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e自动链接数据至形状数据\u003c/li\u003e\n\u003cli\u003e更新已有形状数据而不是新建数据\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"原因分析\"\u003e原因分析\u003c/h2\u003e\n\u003cp\u003e针对问题一，使用录制宏功能，可以发现当设置形状的 ObjectID 与数据源中的 ShapeKey 匹配时，没有录制上任何有效代码，而其它选项均有代码被录制。因此推测 ID(Object Info)不是有效选项。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"vba-code.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/ZrU6nLWj3AzpqKI.png\"\u003e\u003c/p\u003e\n\u003cp\u003e针对问题二，由于在导出数据时，允许重新定义属性的名称，因此推测属性名称在更新数据时起关联作用，即表格中的列名称应与属性的 Name 或 Label 一致。经过多次尝试，应设置列名称为属性的 Label。\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e因此，要在 Visio 中实现外部数据绑定与自动更新，需要完成以下操作:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e在 User Section 中添加新的 ShapeID 属性，并设置其公式为\u0026quot;\u003ccode\u003e=GUARD(ID())\u003c/code\u003e\u0026quot;。\n\u003cimg alt=\"shape-id.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/ytJuX4R3IxpNgrs.png\"\u003e\u003c/li\u003e\n\u003cli\u003e在数据导出窗口中，依次修改导出属性的 Field Name 为其 Label。\n\u003cimg alt=\"define-field-name.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/MRSHE8ay3e2jmoO.png\"\u003e\u003c/li\u003e\n\u003cli\u003e在自动链接窗口中，选择 Shape Field 的值为 User.ShapeID.\n\u003cimg alt=\"link-to-shape-id.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/25/RjM9OdT1m4nqphN.png\"\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e此时，修改后的数据已与形状自动关联。\u003c/p\u003e","title":"解决Visio外部数据绑定失败：自定义形状ID属性"},{"content":" 2025.3.17更新： 将文件另存为VSD格式，然后再另存为VSDX格式即可修复。\n引言 容器是 Visio 中一类可以帮助实现结构化组织和管理其它图形元素的特殊对象。通过容器，您可以将相关的子图形放置在一个框架内，以便更清晰地展示信息和关系。在管理员定义方面，与组合相比，容器可以实现更丰富的预定义内容：形状结构、外观样式、连接点定义等，以满足不同公司对图表样式的要求。在用户操作方面，用户可以通过将子图形拖拽在容器内或容器外轻松实现将子图形加入或移出容器，通过拖拽容器可以实现容器内子图形的一起移动。因此，容器尤其适用于图表、流程图、组织结构图的设计。\n但是，容器作为 Visio2010 的新增特性，Visio 并没有提供关于自定义容器的相关教程及建议，这也使得当前 Visio 容器的定义存在极高的自由度。通常，若将一个对象定义为容器，只需要在该对象 Spreadsheet 中的 User Section 内增加msvStructureType属性，并设置其值为=\u0026quot;Container\u0026quot;。\n但是，这种简单的定义可能会在特定情况下引发意外的文件尾错误。\n问题描述 星期一的时候，我的同事向我演示了他是如何引起这个错误的。首先，他将一条表示管路的线段放在了表示功能单元的容器内。由于这条管路表示外部进来的管路，所以他希望这条线段一端恰好贴在容器边框，另一端落在容器内。随后，他又删除了这条线段。在此之后，当他想要调整容器的尺寸时，出现了这个错误。 当我尝试复现这个错误时，我发现使用 Visio 预定义的容器并不会引发该现象。\n原因分析 通过仔细对比我们自定义的容器和 Visio 预定义的容器，我们确定了以下两个前置条件：\n线段一端必须吸附在容器的几何形状上。当线段被吸附至容器的几何形状上时，点击容器，连接处可以看到如图所示的高亮的连接点。 在默认状态下，拖拽线段至容器的边界不会引发吸附，除非文档模板中预定义或用户手动开启了该功能。该功能位于 View-Visual aids-Snap \u0026amp; Glue-General-Glue to节，勾选 Shape geometery 可以启用该功能。\n被吸附的容器的几何形状必须定义在容器本身，而不是容器组合的子对象。也就是说，表示几何形状的 Geometry Section 位于容器的 Spreadsheet 内。 解决方法 要解决这个问题，我们需要将容器的几何形状定义在容器组合的子对象中。也就是说，在创建自定义容器时，不应在容器自身的 Spreadsheet 中定义 Geometry，而应将容器转换为组合，并将表示容器几何形状的对象作为容器组合的子对象。\n以下给出了建议的自定义容器步骤：\n插入表示容器造型的形状对象； 将这些形状对象使用 Ctrl+G组合成一个组合对象； 打开组合对象的 Spreadsheet，并在 User Section 内增加msvStructureType属性，并设置其值为=\u0026quot;Container\u0026quot;。 ","permalink":"http://localhost:1313/posts/%E4%BF%AE%E5%A4%8Dvisio%E5%AE%B9%E5%99%A8%E8%B0%83%E6%95%B4%E5%B0%BA%E5%AF%B8%E5%BC%95%E5%8F%91%E7%9A%84%E6%84%8F%E5%A4%96%E7%9A%84%E6%96%87%E4%BB%B6%E5%B0%BE%E9%94%99%E8%AF%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95/","summary":"\u003cblockquote\u003e\n\u003cp\u003e2025.3.17更新：\n将文件另存为VSD格式，然后再另存为VSDX格式即可修复。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2 id=\"引言\"\u003e引言\u003c/h2\u003e\n\u003cp\u003e容器是 Visio 中一类可以帮助实现结构化组织和管理其它图形元素的特殊对象。通过容器，您可以将相关的子图形放置在一个框架内，以便更清晰地展示信息和关系。在管理员定义方面，与组合相比，容器可以实现更丰富的预定义内容：形状结构、外观样式、连接点定义等，以满足不同公司对图表样式的要求。在用户操作方面，用户可以通过将子图形拖拽在容器内或容器外轻松实现将子图形加入或移出容器，通过拖拽容器可以实现容器内子图形的一起移动。因此，容器尤其适用于图表、流程图、组织结构图的设计。\u003c/p\u003e\n\u003cp\u003e但是，容器作为 Visio2010 的新增特性，Visio 并没有提供关于自定义容器的相关教程及建议，这也使得当前 Visio 容器的定义存在极高的自由度。通常，若将一个对象定义为容器，只需要在该对象 Spreadsheet 中的 User Section 内增加\u003ccode\u003emsvStructureType\u003c/code\u003e属性，并设置其值为\u003ccode\u003e=\u0026quot;Container\u0026quot;\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"create-a-container.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/F7hI19NnCyGziPt.png\"\u003e\n但是，这种简单的定义可能会在特定情况下引发\u003ccode\u003e意外的文件尾\u003c/code\u003e错误。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"unexpected-end-of-file.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/TYaG18djwNZW2sL.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"问题描述\"\u003e问题描述\u003c/h2\u003e\n\u003cp\u003e星期一的时候，我的同事向我演示了他是如何引起这个错误的。首先，他将一条表示管路的线段放在了表示功能单元的容器内。由于这条管路表示外部进来的管路，所以他希望这条线段一端恰好贴在容器边框，另一端落在容器内。随后，他又删除了这条线段。在此之后，当他想要调整容器的尺寸时，出现了这个错误。\n\u003cimg alt=\"a-line-in-the-container.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/7PwEGvabXVqdio6.png\"\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"error-when-resize-container-after-remove-line.png.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/bDJ3cExyn1Qehsk.png\"\u003e\u003c/p\u003e\n\u003cp\u003e当我尝试复现这个错误时，我发现使用 Visio 预定义的容器并不会引发该现象。\u003c/p\u003e\n\u003ch2 id=\"原因分析\"\u003e原因分析\u003c/h2\u003e\n\u003cp\u003e通过仔细对比我们自定义的容器和 Visio 预定义的容器，我们确定了以下两个前置条件：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e线段一端必须吸附在容器的几何形状上。当线段被吸附至容器的几何形状上时，点击容器，连接处可以看到如图所示的高亮的连接点。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"glue-line-to-container-geometry.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/CDl6AM3PNg4HtLG.png\"\u003e\u003c/p\u003e\n\u003cp\u003e在默认状态下，拖拽线段至容器的边界不会引发吸附，除非文档模板中预定义或用户手动开启了该功能。该功能位于 \u003ccode\u003eView\u003c/code\u003e-\u003ccode\u003eVisual aids\u003c/code\u003e-\u003ccode\u003eSnap \u0026amp; Glue\u003c/code\u003e-\u003ccode\u003eGeneral\u003c/code\u003e-\u003ccode\u003eGlue to\u003c/code\u003e节，勾选 Shape geometery 可以启用该功能。\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"snap-and-glue.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/RVMuCWfdjAyXeiE.png\"\u003e\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e被吸附的容器的几何形状必须定义在容器本身，而不是容器组合的子对象。也就是说，表示几何形状的 Geometry Section 位于容器的 Spreadsheet 内。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u003cimg alt=\"geometry-defined-in-container.png\" loading=\"lazy\" src=\"https://s2.loli.net/2023/06/01/imehkFnI6H94NzU.png\"\u003e\u003c/p\u003e\n\u003ch2 id=\"解决方法\"\u003e解决方法\u003c/h2\u003e\n\u003cp\u003e要解决这个问题，我们需要将容器的几何形状定义在容器组合的子对象中。也就是说，在创建自定义容器时，不应在容器自身的 Spreadsheet 中定义 Geometry，而应将容器转换为组合，并将表示容器几何形状的对象作为容器组合的子对象。\u003c/p\u003e\n\u003cp\u003e以下给出了建议的自定义容器步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e插入表示容器造型的形状对象；\u003c/li\u003e\n\u003cli\u003e将这些形状对象使用 \u003ccode\u003eCtrl+G\u003c/code\u003e组合成一个组合对象；\u003c/li\u003e\n\u003cli\u003e打开组合对象的 Spreadsheet，并在 User Section 内增加\u003ccode\u003emsvStructureType\u003c/code\u003e属性，并设置其值为\u003ccode\u003e=\u0026quot;Container\u0026quot;\u003c/code\u003e。\u003c/li\u003e\n\u003c/ol\u003e","title":"修复Visio容器调整尺寸引发的意外的文件尾错误：正确的容器定义方法"}]